// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_format_svg_FillType
#include <format/svg/FillType.h>
#endif
#ifndef INCLUDED_format_svg_Path
#include <format/svg/Path.h>
#endif
#ifndef INCLUDED_format_svg_PathSegment
#include <format/svg/PathSegment.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_92a4da35fc358e4d_15_new,"format.svg.Path","new",0x8725c818,"format.svg.Path.new","format/svg/Path.hx",15,0x6b7aa216)
namespace format{
namespace svg{

void Path_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_92a4da35fc358e4d_15_new)
            	}

Dynamic Path_obj::__CreateEmpty() { return new Path_obj; }

void *Path_obj::_hx_vtable = 0;

Dynamic Path_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Path_obj > _hx_result = new Path_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Path_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7f670da6;
}


Path_obj::Path_obj()
{
}

void Path_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Path);
	HX_MARK_MEMBER_NAME(matrix,"matrix");
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(font_size,"font_size");
	HX_MARK_MEMBER_NAME(fill,"fill");
	HX_MARK_MEMBER_NAME(alpha,"alpha");
	HX_MARK_MEMBER_NAME(fill_alpha,"fill_alpha");
	HX_MARK_MEMBER_NAME(stroke_alpha,"stroke_alpha");
	HX_MARK_MEMBER_NAME(stroke_colour,"stroke_colour");
	HX_MARK_MEMBER_NAME(stroke_width,"stroke_width");
	HX_MARK_MEMBER_NAME(stroke_caps,"stroke_caps");
	HX_MARK_MEMBER_NAME(joint_style,"joint_style");
	HX_MARK_MEMBER_NAME(miter_limit,"miter_limit");
	HX_MARK_MEMBER_NAME(segments,"segments");
	HX_MARK_END_CLASS();
}

void Path_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(matrix,"matrix");
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(font_size,"font_size");
	HX_VISIT_MEMBER_NAME(fill,"fill");
	HX_VISIT_MEMBER_NAME(alpha,"alpha");
	HX_VISIT_MEMBER_NAME(fill_alpha,"fill_alpha");
	HX_VISIT_MEMBER_NAME(stroke_alpha,"stroke_alpha");
	HX_VISIT_MEMBER_NAME(stroke_colour,"stroke_colour");
	HX_VISIT_MEMBER_NAME(stroke_width,"stroke_width");
	HX_VISIT_MEMBER_NAME(stroke_caps,"stroke_caps");
	HX_VISIT_MEMBER_NAME(joint_style,"joint_style");
	HX_VISIT_MEMBER_NAME(miter_limit,"miter_limit");
	HX_VISIT_MEMBER_NAME(segments,"segments");
}

::hx::Val Path_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { return ::hx::Val( name ); }
		if (HX_FIELD_EQ(inName,"fill") ) { return ::hx::Val( fill ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"alpha") ) { return ::hx::Val( alpha ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { return ::hx::Val( matrix ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"segments") ) { return ::hx::Val( segments ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"font_size") ) { return ::hx::Val( font_size ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"fill_alpha") ) { return ::hx::Val( fill_alpha ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"stroke_caps") ) { return ::hx::Val( stroke_caps ); }
		if (HX_FIELD_EQ(inName,"joint_style") ) { return ::hx::Val( joint_style ); }
		if (HX_FIELD_EQ(inName,"miter_limit") ) { return ::hx::Val( miter_limit ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"stroke_alpha") ) { return ::hx::Val( stroke_alpha ); }
		if (HX_FIELD_EQ(inName,"stroke_width") ) { return ::hx::Val( stroke_width ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"stroke_colour") ) { return ::hx::Val( stroke_colour ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Path_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { name=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fill") ) { fill=inValue.Cast<  ::format::svg::FillType >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"alpha") ) { alpha=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { matrix=inValue.Cast<  ::openfl::geom::Matrix >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"segments") ) { segments=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"font_size") ) { font_size=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"fill_alpha") ) { fill_alpha=inValue.Cast< Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"stroke_caps") ) { stroke_caps=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"joint_style") ) { joint_style=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"miter_limit") ) { miter_limit=inValue.Cast< Float >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"stroke_alpha") ) { stroke_alpha=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stroke_width") ) { stroke_width=inValue.Cast< Float >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"stroke_colour") ) { stroke_colour=inValue.Cast<  ::Dynamic >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Path_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("matrix",41,36,c8,bb));
	outFields->push(HX_("name",4b,72,ff,48));
	outFields->push(HX_("font_size",71,f0,12,18));
	outFields->push(HX_("fill",83,ce,bb,43));
	outFields->push(HX_("alpha",5e,a7,96,21));
	outFields->push(HX_("fill_alpha",62,01,84,ec));
	outFields->push(HX_("stroke_alpha",57,3c,28,73));
	outFields->push(HX_("stroke_colour",33,8d,57,d4));
	outFields->push(HX_("stroke_width",ff,4a,f4,1b));
	outFields->push(HX_("stroke_caps",48,09,58,7a));
	outFields->push(HX_("joint_style",3c,39,d2,2c));
	outFields->push(HX_("miter_limit",41,b8,00,d9));
	outFields->push(HX_("segments",60,ed,26,4e));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Path_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::openfl::geom::Matrix */ ,(int)offsetof(Path_obj,matrix),HX_("matrix",41,36,c8,bb)},
	{::hx::fsString,(int)offsetof(Path_obj,name),HX_("name",4b,72,ff,48)},
	{::hx::fsFloat,(int)offsetof(Path_obj,font_size),HX_("font_size",71,f0,12,18)},
	{::hx::fsObject /*  ::format::svg::FillType */ ,(int)offsetof(Path_obj,fill),HX_("fill",83,ce,bb,43)},
	{::hx::fsFloat,(int)offsetof(Path_obj,alpha),HX_("alpha",5e,a7,96,21)},
	{::hx::fsFloat,(int)offsetof(Path_obj,fill_alpha),HX_("fill_alpha",62,01,84,ec)},
	{::hx::fsFloat,(int)offsetof(Path_obj,stroke_alpha),HX_("stroke_alpha",57,3c,28,73)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Path_obj,stroke_colour),HX_("stroke_colour",33,8d,57,d4)},
	{::hx::fsFloat,(int)offsetof(Path_obj,stroke_width),HX_("stroke_width",ff,4a,f4,1b)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Path_obj,stroke_caps),HX_("stroke_caps",48,09,58,7a)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Path_obj,joint_style),HX_("joint_style",3c,39,d2,2c)},
	{::hx::fsFloat,(int)offsetof(Path_obj,miter_limit),HX_("miter_limit",41,b8,00,d9)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Path_obj,segments),HX_("segments",60,ed,26,4e)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Path_obj_sStaticStorageInfo = 0;
#endif

static ::String Path_obj_sMemberFields[] = {
	HX_("matrix",41,36,c8,bb),
	HX_("name",4b,72,ff,48),
	HX_("font_size",71,f0,12,18),
	HX_("fill",83,ce,bb,43),
	HX_("alpha",5e,a7,96,21),
	HX_("fill_alpha",62,01,84,ec),
	HX_("stroke_alpha",57,3c,28,73),
	HX_("stroke_colour",33,8d,57,d4),
	HX_("stroke_width",ff,4a,f4,1b),
	HX_("stroke_caps",48,09,58,7a),
	HX_("joint_style",3c,39,d2,2c),
	HX_("miter_limit",41,b8,00,d9),
	HX_("segments",60,ed,26,4e),
	::String(null()) };

::hx::Class Path_obj::__mClass;

void Path_obj::__register()
{
	Path_obj _hx_dummy;
	Path_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("format.svg.Path",26,1c,f2,6d);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Path_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Path_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Path_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Path_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace format
} // end namespace svg
