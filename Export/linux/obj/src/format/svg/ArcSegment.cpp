// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_format_gfx_Gfx
#include <format/gfx/Gfx.h>
#endif
#ifndef INCLUDED_format_svg_ArcSegment
#include <format/svg/ArcSegment.h>
#endif
#ifndef INCLUDED_format_svg_PathSegment
#include <format/svg/PathSegment.h>
#endif
#ifndef INCLUDED_format_svg_RenderContext
#include <format/svg/RenderContext.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_5813559f4ecaf796_233_new,"format.svg.ArcSegment","new",0x3249feb4,"format.svg.ArcSegment.new","format/svg/PathSegment.hx",233,0x6d7bc4b3)
HX_LOCAL_STACK_FRAME(_hx_pos_5813559f4ecaf796_245_toGfx,"format.svg.ArcSegment","toGfx",0x52ad9e12,"format.svg.ArcSegment.toGfx","format/svg/PathSegment.hx",245,0x6d7bc4b3)
HX_LOCAL_STACK_FRAME(_hx_pos_5813559f4ecaf796_360_getType,"format.svg.ArcSegment","getType",0x50d98ac4,"format.svg.ArcSegment.getType","format/svg/PathSegment.hx",360,0x6d7bc4b3)
namespace format{
namespace svg{

void ArcSegment_obj::__construct(Float inX1,Float inY1,Float inRX,Float inRY,Float inRotation,bool inLargeArc,bool inSweep,Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_5813559f4ecaf796_233_new)
HXLINE( 234)		this->x1 = inX1;
HXLINE( 235)		this->y1 = inY1;
HXLINE( 236)		super::__construct(x,y);
HXLINE( 237)		this->rx = inRX;
HXLINE( 238)		this->ry = inRY;
HXLINE( 239)		this->phi = inRotation;
HXLINE( 240)		this->fA = inLargeArc;
HXLINE( 241)		this->fS = inSweep;
            	}

Dynamic ArcSegment_obj::__CreateEmpty() { return new ArcSegment_obj; }

void *ArcSegment_obj::_hx_vtable = 0;

Dynamic ArcSegment_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ArcSegment_obj > _hx_result = new ArcSegment_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8]);
	return _hx_result;
}

bool ArcSegment_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1e33d74a) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x1e33d74a;
	} else {
		return inClassId==(int)0x77129341;
	}
}

void ArcSegment_obj::toGfx( ::format::gfx::Gfx inGfx, ::format::svg::RenderContext ioContext){
            	HX_STACKFRAME(&_hx_pos_5813559f4ecaf796_245_toGfx)
HXLINE( 246)		bool _hx_tmp;
HXDLIN( 246)		if ((this->x1 == this->x)) {
HXLINE( 246)			_hx_tmp = (this->y1 == this->y);
            		}
            		else {
HXLINE( 246)			_hx_tmp = false;
            		}
HXDLIN( 246)		if (_hx_tmp) {
HXLINE( 247)			return;
            		}
HXLINE( 248)		ioContext->setLast(this->x,this->y);
HXLINE( 249)		bool _hx_tmp1;
HXDLIN( 249)		if ((this->rx != 0)) {
HXLINE( 249)			_hx_tmp1 = (this->ry == 0);
            		}
            		else {
HXLINE( 249)			_hx_tmp1 = true;
            		}
HXDLIN( 249)		if (_hx_tmp1) {
HXLINE( 251)			inGfx->lineTo(ioContext->lastX,ioContext->lastY);
HXLINE( 252)			return;
            		}
HXLINE( 254)		if ((this->rx < 0)) {
HXLINE( 254)			this->rx = -(this->rx);
            		}
HXLINE( 255)		if ((this->ry < 0)) {
HXLINE( 255)			this->ry = -(this->ry);
            		}
HXLINE( 258)		Float p = ((this->phi * ::Math_obj::PI) / ((Float)180.0));
HXLINE( 259)		Float cos = ::Math_obj::cos(p);
HXLINE( 260)		Float sin = ::Math_obj::sin(p);
HXLINE( 263)		Float dx = ((this->x1 - this->x) * ((Float)0.5));
HXLINE( 264)		Float dy = ((this->y1 - this->y) * ((Float)0.5));
HXLINE( 265)		Float x1_ = ((cos * dx) + (sin * dy));
HXLINE( 266)		Float y1_ = ((-(sin) * dx) + (cos * dy));
HXLINE( 269)		Float rx2 = (this->rx * this->rx);
HXLINE( 270)		Float ry2 = (this->ry * this->ry);
HXLINE( 271)		Float x1_2 = (x1_ * x1_);
HXLINE( 272)		Float y1_2 = (y1_ * y1_);
HXLINE( 273)		Float s = ((((rx2 * ry2) - (rx2 * y1_2)) - (ry2 * x1_2)) / ((rx2 * y1_2) + (ry2 * x1_2)));
HXLINE( 275)		if ((s < 0)) {
HXLINE( 276)			s = ( (Float)(0) );
            		}
            		else {
HXLINE( 277)			if ((this->fA == this->fS)) {
HXLINE( 278)				s = -(::Math_obj::sqrt(s));
            			}
            			else {
HXLINE( 280)				s = ::Math_obj::sqrt(s);
            			}
            		}
HXLINE( 282)		Float cx_ = (((s * this->rx) * y1_) / this->ry);
HXLINE( 283)		Float cy_ = (((-(s) * this->ry) * x1_) / this->rx);
HXLINE( 288)		Float xm = ((this->x1 + this->x) * ((Float)0.5));
HXLINE( 289)		Float ym = ((this->y1 + this->y) * ((Float)0.5));
HXLINE( 291)		Float cx = (((cos * cx_) - (sin * cy_)) + xm);
HXLINE( 292)		Float cy = (((sin * cx_) + (cos * cy_)) + ym);
HXLINE( 294)		Float theta = ::Math_obj::atan2(((y1_ - cy_) / this->ry),((x1_ - cx_) / this->rx));
HXLINE( 295)		Float dtheta = (::Math_obj::atan2(((-(y1_) - cy_) / this->ry),((-(x1_) - cx_) / this->rx)) - theta);
HXLINE( 297)		bool _hx_tmp2;
HXDLIN( 297)		if (this->fS) {
HXLINE( 297)			_hx_tmp2 = (dtheta < 0);
            		}
            		else {
HXLINE( 297)			_hx_tmp2 = false;
            		}
HXDLIN( 297)		if (_hx_tmp2) {
HXLINE( 298)			dtheta = (dtheta + (((Float)2.0) * ::Math_obj::PI));
            		}
            		else {
HXLINE( 299)			bool _hx_tmp;
HXDLIN( 299)			if (!(this->fS)) {
HXLINE( 299)				_hx_tmp = (dtheta > 0);
            			}
            			else {
HXLINE( 299)				_hx_tmp = false;
            			}
HXDLIN( 299)			if (_hx_tmp) {
HXLINE( 300)				dtheta = (dtheta - (((Float)2.0) * ::Math_obj::PI));
            			}
            		}
HXLINE( 303)		 ::openfl::geom::Matrix m = ioContext->matrix;
HXLINE( 316)		Float Txc;
HXLINE( 317)		Float Txs;
HXLINE( 318)		Float Tx0;
HXLINE( 319)		Float Tyc;
HXLINE( 320)		Float Tys;
HXLINE( 321)		Float Ty0;
HXLINE( 322)		if (::hx::IsNotNull( m )) {
HXLINE( 324)			Txc = (m->a * this->rx);
HXLINE( 325)			Txs = (m->c * this->ry);
HXLINE( 326)			Tx0 = (((m->a * cx) + (m->c * cy)) + m->tx);
HXLINE( 327)			Tyc = (m->b * this->rx);
HXLINE( 328)			Tys = (m->d * this->ry);
HXLINE( 329)			Ty0 = (((m->b * cx) + (m->d * cy)) + m->ty);
            		}
            		else {
HXLINE( 333)			Txc = this->rx;
HXLINE( 334)			Txs = ( (Float)(0) );
HXLINE( 335)			Tx0 = (cx + m->tx);
HXLINE( 336)			Tyc = ( (Float)(0) );
HXLINE( 337)			Tys = this->ry;
HXLINE( 338)			Ty0 = (cy + m->ty);
            		}
HXLINE( 341)		Float len = (::Math_obj::abs(dtheta) * ::Math_obj::sqrt(((((Txc * Txc) + (Txs * Txs)) + (Tyc * Tyc)) + (Tys * Tys))));
HXLINE( 343)		len = (len * ( (Float)(5) ));
HXLINE( 344)		int steps = ::Math_obj::round(len);
HXLINE( 347)		if ((steps > 1)) {
HXLINE( 349)			dtheta = (dtheta / ( (Float)(steps) ));
HXLINE( 350)			{
HXLINE( 350)				int _g = 1;
HXDLIN( 350)				int _g1 = (steps - 1);
HXDLIN( 350)				while((_g < _g1)){
HXLINE( 350)					_g = (_g + 1);
HXDLIN( 350)					int i = (_g - 1);
HXLINE( 352)					Float c = ::Math_obj::cos(theta);
HXLINE( 353)					Float s = ::Math_obj::sin(theta);
HXLINE( 354)					theta = (theta + dtheta);
HXLINE( 355)					inGfx->lineTo((((Txc * c) + (Txs * s)) + Tx0),(((Tyc * c) + (Tys * s)) + Ty0));
            				}
            			}
            		}
HXLINE( 358)		inGfx->lineTo(ioContext->lastX,ioContext->lastY);
            	}


int ArcSegment_obj::getType(){
            	HX_STACKFRAME(&_hx_pos_5813559f4ecaf796_360_getType)
HXDLIN( 360)		return 5;
            	}



::hx::ObjectPtr< ArcSegment_obj > ArcSegment_obj::__new(Float inX1,Float inY1,Float inRX,Float inRY,Float inRotation,bool inLargeArc,bool inSweep,Float x,Float y) {
	::hx::ObjectPtr< ArcSegment_obj > __this = new ArcSegment_obj();
	__this->__construct(inX1,inY1,inRX,inRY,inRotation,inLargeArc,inSweep,x,y);
	return __this;
}

::hx::ObjectPtr< ArcSegment_obj > ArcSegment_obj::__alloc(::hx::Ctx *_hx_ctx,Float inX1,Float inY1,Float inRX,Float inRY,Float inRotation,bool inLargeArc,bool inSweep,Float x,Float y) {
	ArcSegment_obj *__this = (ArcSegment_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ArcSegment_obj), false, "format.svg.ArcSegment"));
	*(void **)__this = ArcSegment_obj::_hx_vtable;
	__this->__construct(inX1,inY1,inRX,inRY,inRotation,inLargeArc,inSweep,x,y);
	return __this;
}

ArcSegment_obj::ArcSegment_obj()
{
}

::hx::Val ArcSegment_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { return ::hx::Val( x1 ); }
		if (HX_FIELD_EQ(inName,"y1") ) { return ::hx::Val( y1 ); }
		if (HX_FIELD_EQ(inName,"rx") ) { return ::hx::Val( rx ); }
		if (HX_FIELD_EQ(inName,"ry") ) { return ::hx::Val( ry ); }
		if (HX_FIELD_EQ(inName,"fA") ) { return ::hx::Val( fA ); }
		if (HX_FIELD_EQ(inName,"fS") ) { return ::hx::Val( fS ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"phi") ) { return ::hx::Val( phi ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"toGfx") ) { return ::hx::Val( toGfx_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getType") ) { return ::hx::Val( getType_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val ArcSegment_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { x1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y1") ) { y1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"rx") ) { rx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ry") ) { ry=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fA") ) { fA=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fS") ) { fS=inValue.Cast< bool >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"phi") ) { phi=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ArcSegment_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x1",b9,68,00,00));
	outFields->push(HX_("y1",98,69,00,00));
	outFields->push(HX_("rx",c6,63,00,00));
	outFields->push(HX_("ry",c7,63,00,00));
	outFields->push(HX_("phi",71,57,55,00));
	outFields->push(HX_("fA",1b,59,00,00));
	outFields->push(HX_("fS",2d,59,00,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ArcSegment_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(ArcSegment_obj,x1),HX_("x1",b9,68,00,00)},
	{::hx::fsFloat,(int)offsetof(ArcSegment_obj,y1),HX_("y1",98,69,00,00)},
	{::hx::fsFloat,(int)offsetof(ArcSegment_obj,rx),HX_("rx",c6,63,00,00)},
	{::hx::fsFloat,(int)offsetof(ArcSegment_obj,ry),HX_("ry",c7,63,00,00)},
	{::hx::fsFloat,(int)offsetof(ArcSegment_obj,phi),HX_("phi",71,57,55,00)},
	{::hx::fsBool,(int)offsetof(ArcSegment_obj,fA),HX_("fA",1b,59,00,00)},
	{::hx::fsBool,(int)offsetof(ArcSegment_obj,fS),HX_("fS",2d,59,00,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *ArcSegment_obj_sStaticStorageInfo = 0;
#endif

static ::String ArcSegment_obj_sMemberFields[] = {
	HX_("x1",b9,68,00,00),
	HX_("y1",98,69,00,00),
	HX_("rx",c6,63,00,00),
	HX_("ry",c7,63,00,00),
	HX_("phi",71,57,55,00),
	HX_("fA",1b,59,00,00),
	HX_("fS",2d,59,00,00),
	HX_("toGfx",be,32,10,14),
	HX_("getType",70,a2,8b,1f),
	::String(null()) };

::hx::Class ArcSegment_obj::__mClass;

void ArcSegment_obj::__register()
{
	ArcSegment_obj _hx_dummy;
	ArcSegment_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("format.svg.ArcSegment",c2,d4,57,75);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ArcSegment_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ArcSegment_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ArcSegment_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ArcSegment_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace format
} // end namespace svg
