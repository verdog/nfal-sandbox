// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_Xml
#include <Xml.h>
#endif
#ifndef INCLUDED__Xml_XmlType_Impl_
#include <_Xml/XmlType_Impl_.h>
#endif
#ifndef INCLUDED_format_gfx_Gradient
#include <format/gfx/Gradient.h>
#endif
#ifndef INCLUDED_format_svg_DisplayElement
#include <format/svg/DisplayElement.h>
#endif
#ifndef INCLUDED_format_svg_DrawSegment
#include <format/svg/DrawSegment.h>
#endif
#ifndef INCLUDED_format_svg_FillType
#include <format/svg/FillType.h>
#endif
#ifndef INCLUDED_format_svg_Grad
#include <format/svg/Grad.h>
#endif
#ifndef INCLUDED_format_svg_Group
#include <format/svg/Group.h>
#endif
#ifndef INCLUDED_format_svg_MoveSegment
#include <format/svg/MoveSegment.h>
#endif
#ifndef INCLUDED_format_svg_Path
#include <format/svg/Path.h>
#endif
#ifndef INCLUDED_format_svg_PathParser
#include <format/svg/PathParser.h>
#endif
#ifndef INCLUDED_format_svg_PathSegment
#include <format/svg/PathSegment.h>
#endif
#ifndef INCLUDED_format_svg_QuadraticSegment
#include <format/svg/QuadraticSegment.h>
#endif
#ifndef INCLUDED_format_svg_SVGData
#include <format/svg/SVGData.h>
#endif
#ifndef INCLUDED_format_svg_Text
#include <format/svg/Text.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_xml_Printer
#include <haxe/xml/Printer.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_49_new,"format.svg.SVGData","new",0x51c8ae3f,"format.svg.SVGData.new","format/svg/SVGData.hx",49,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_89_trimToFloat,"format.svg.SVGData","trimToFloat",0x8f41323e,"format.svg.SVGData.trimToFloat","format/svg/SVGData.hx",89,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_96_applyTransform,"format.svg.SVGData","applyTransform",0xb6802a9f,"format.svg.SVGData.applyTransform","format/svg/SVGData.hx",96,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_163_dumpGroup,"format.svg.SVGData","dumpGroup",0x5544588a,"format.svg.SVGData.dumpGroup","format/svg/SVGData.hx",163,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_183_getColorStyle,"format.svg.SVGData","getColorStyle",0x73c6a3a3,"format.svg.SVGData.getColorStyle","format/svg/SVGData.hx",183,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_210_getFillStyle,"format.svg.SVGData","getFillStyle",0x0c815679,"format.svg.SVGData.getFillStyle","format/svg/SVGData.hx",210,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_259_getFloat,"format.svg.SVGData","getFloat",0x54cd4ee7,"format.svg.SVGData.getFloat","format/svg/SVGData.hx",259,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_269_getFloatStyle,"format.svg.SVGData","getFloatStyle",0x6df360ca,"format.svg.SVGData.getFloatStyle","format/svg/SVGData.hx",269,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_284_getStyleAndConvert,"format.svg.SVGData","getStyleAndConvert",0xa0c8e978,"format.svg.SVGData.getStyleAndConvert","format/svg/SVGData.hx",284,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_299_getStrokeStyle,"format.svg.SVGData","getStrokeStyle",0xa6e4f9e4,"format.svg.SVGData.getStrokeStyle","format/svg/SVGData.hx",299,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_333_getStyle,"format.svg.SVGData","getStyle",0xd6542e7c,"format.svg.SVGData.getStyle","format/svg/SVGData.hx",333,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_352_getStyles,"format.svg.SVGData","getStyles",0xb3547e77,"format.svg.SVGData.getStyles","format/svg/SVGData.hx",352,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_391_loadDefs,"format.svg.SVGData","loadDefs",0xa5659e15,"format.svg.SVGData.loadDefs","format/svg/SVGData.hx",391,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_420_loadGradient,"format.svg.SVGData","loadGradient",0x8e0e1477,"format.svg.SVGData.loadGradient","format/svg/SVGData.hx",420,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_493_loadGroup,"format.svg.SVGData","loadGroup",0xd6570e58,"format.svg.SVGData.loadGroup","format/svg/SVGData.hx",493,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_606_loadPath,"format.svg.SVGData","loadPath",0xad5130ac,"format.svg.SVGData.loadPath","format/svg/SVGData.hx",606,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_714_loadText,"format.svg.SVGData","loadText",0xaff917b4,"format.svg.SVGData.loadText","format/svg/SVGData.hx",714,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_756_parseHex,"format.svg.SVGData","parseHex",0xc8d0c629,"format.svg.SVGData.parseHex","format/svg/SVGData.hx",756,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_769_parseRGBMatch,"format.svg.SVGData","parseRGBMatch",0xaec30cea,"format.svg.SVGData.parseRGBMatch","format/svg/SVGData.hx",769,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_29_boot,"format.svg.SVGData","boot",0x35e8c973,"format.svg.SVGData.boot","format/svg/SVGData.hx",29,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_30_boot,"format.svg.SVGData","boot",0x35e8c973,"format.svg.SVGData.boot","format/svg/SVGData.hx",30,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_31_boot,"format.svg.SVGData","boot",0x35e8c973,"format.svg.SVGData.boot","format/svg/SVGData.hx",31,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_32_boot,"format.svg.SVGData","boot",0x35e8c973,"format.svg.SVGData.boot","format/svg/SVGData.hx",32,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_33_boot,"format.svg.SVGData","boot",0x35e8c973,"format.svg.SVGData.boot","format/svg/SVGData.hx",33,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_34_boot,"format.svg.SVGData","boot",0x35e8c973,"format.svg.SVGData.boot","format/svg/SVGData.hx",34,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_35_boot,"format.svg.SVGData","boot",0x35e8c973,"format.svg.SVGData.boot","format/svg/SVGData.hx",35,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_36_boot,"format.svg.SVGData","boot",0x35e8c973,"format.svg.SVGData.boot","format/svg/SVGData.hx",36,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_37_boot,"format.svg.SVGData","boot",0x35e8c973,"format.svg.SVGData.boot","format/svg/SVGData.hx",37,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_38_boot,"format.svg.SVGData","boot",0x35e8c973,"format.svg.SVGData.boot","format/svg/SVGData.hx",38,0x27702913)
HX_LOCAL_STACK_FRAME(_hx_pos_a2b4c26a6f4db273_39_boot,"format.svg.SVGData","boot",0x35e8c973,"format.svg.SVGData.boot","format/svg/SVGData.hx",39,0x27702913)
namespace format{
namespace svg{

void SVGData_obj::__construct( ::Xml inXML,::hx::Null< bool >  __o_inConvertCubics){
            		bool inConvertCubics = __o_inConvertCubics.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_49_new)
HXLINE(  51)		super::__construct();
HXLINE(  53)		 ::Xml svg = inXML->firstElement();
HXLINE(  55)		bool _hx_tmp;
HXDLIN(  55)		if (::hx::IsNotNull( svg )) {
HXLINE(  55)			if ((svg->nodeType != ::Xml_obj::Element)) {
HXLINE(  55)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(svg->nodeType))));
            			}
HXDLIN(  55)			if ((svg->nodeName != HX_("svg",64,aa,57,00))) {
HXLINE(  55)				if ((svg->nodeType != ::Xml_obj::Element)) {
HXLINE(  55)					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(svg->nodeType))));
            				}
HXDLIN(  55)				_hx_tmp = (svg->nodeName != HX_("svg:svg",ce,b6,34,51));
            			}
            			else {
HXLINE(  55)				_hx_tmp = false;
            			}
            		}
            		else {
HXLINE(  55)			_hx_tmp = true;
            		}
HXDLIN(  55)		if (_hx_tmp) {
HXLINE(  56)			::String _hx_tmp;
HXDLIN(  56)			if (::hx::IsNull( svg )) {
HXLINE(  56)				_hx_tmp = HX_("null",87,9e,0e,49);
            			}
            			else {
HXLINE(  56)				if ((svg->nodeType != ::Xml_obj::Element)) {
HXLINE(  56)					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(svg->nodeType))));
            				}
HXDLIN(  56)				_hx_tmp = svg->nodeName;
            			}
HXDLIN(  56)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(((HX_("Not an SVG file (",46,d4,ec,af) + _hx_tmp) + HX_(")",29,00,00,00))));
            		}
HXLINE(  58)		this->mGrads =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  59)		this->mPathParser =  ::format::svg::PathParser_obj::__alloc( HX_CTX );
HXLINE(  60)		this->mConvertCubics = inConvertCubics;
HXLINE(  62)		this->width = this->getFloatStyle(HX_("width",06,b6,62,ca),svg,null(),((Float)0.0));
HXLINE(  63)		this->height = this->getFloatStyle(HX_("height",e7,07,4c,02),svg,null(),((Float)0.0));
HXLINE(  65)		bool _hx_tmp1;
HXDLIN(  65)		if ((this->width == 0)) {
HXLINE(  65)			_hx_tmp1 = (this->height == 0);
            		}
            		else {
HXLINE(  65)			_hx_tmp1 = false;
            		}
HXDLIN(  65)		if (_hx_tmp1) {
HXLINE(  66)			this->width = (this->height = ( (Float)(400) ));
            		}
            		else {
HXLINE(  67)			if ((this->width == 0)) {
HXLINE(  68)				this->width = this->height;
            			}
            			else {
HXLINE(  69)				if ((this->height == 0)) {
HXLINE(  70)					this->height = this->width;
            				}
            			}
            		}
HXLINE(  72)		 ::openfl::geom::Rectangle viewBox =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,0,0,this->width,this->height);
HXLINE(  74)		if (svg->exists(HX_("viewBox",a6,10,b1,9c))) {
HXLINE(  76)			::String vbox = svg->get(HX_("viewBox",a6,10,b1,9c));
HXLINE(  77)			::Array< ::String > params;
HXDLIN(  77)			if ((vbox.indexOf(HX_(",",2c,00,00,00),null()) != -1)) {
HXLINE(  77)				params = vbox.split(HX_(",",2c,00,00,00));
            			}
            			else {
HXLINE(  77)				params = vbox.split(HX_(" ",20,00,00,00));
            			}
HXLINE(  78)			Float viewBox1 = ::Std_obj::parseFloat(::StringTools_obj::trim(params->__get(0)));
HXDLIN(  78)			Float viewBox2 = ::Std_obj::parseFloat(::StringTools_obj::trim(params->__get(1)));
HXDLIN(  78)			Float viewBox3 = ::Std_obj::parseFloat(::StringTools_obj::trim(params->__get(2)));
HXDLIN(  78)			viewBox =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,viewBox1,viewBox2,viewBox3,::Std_obj::parseFloat(::StringTools_obj::trim(params->__get(3))));
            		}
HXLINE(  82)		this->loadGroup(::hx::ObjectPtr<OBJ_>(this),svg, ::openfl::geom::Matrix_obj::__alloc( HX_CTX ,1,0,0,1,-(viewBox->x),-(viewBox->y)),null());
            	}

Dynamic SVGData_obj::__CreateEmpty() { return new SVGData_obj; }

void *SVGData_obj::_hx_vtable = 0;

Dynamic SVGData_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< SVGData_obj > _hx_result = new SVGData_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool SVGData_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x131a3f9d) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x131a3f9d;
	} else {
		return inClassId==(int)0x76432db2;
	}
}

Float SVGData_obj::trimToFloat(::String value){
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_89_trimToFloat)
HXDLIN(  89)		return ::Std_obj::parseFloat(::StringTools_obj::trim(value));
            	}


HX_DEFINE_DYNAMIC_FUNC1(SVGData_obj,trimToFloat,return )

Float SVGData_obj::applyTransform( ::openfl::geom::Matrix ioMatrix,::String inTrans){
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_96_applyTransform)
HXLINE(  98)		Float scale = ((Float)1.0);
HXLINE( 100)		if (::format::svg::SVGData_obj::mTranslateMatch->match(inTrans)) {
HXLINE( 104)			Float _hx_tmp = ::Std_obj::parseFloat(::format::svg::SVGData_obj::mTranslateMatch->matched(1));
HXDLIN( 104)			ioMatrix->translate(_hx_tmp,::Std_obj::parseFloat(::format::svg::SVGData_obj::mTranslateMatch->matched(2)));
            		}
            		else {
HXLINE( 106)			if (::format::svg::SVGData_obj::mScaleMatch->match(inTrans)) {
HXLINE( 109)				Float s = ::Std_obj::parseFloat(::format::svg::SVGData_obj::mScaleMatch->matched(1));
HXLINE( 110)				ioMatrix->scale(s,s);
HXLINE( 111)				scale = s;
            			}
            			else {
HXLINE( 113)				if (::format::svg::SVGData_obj::mMatrixMatch->match(inTrans)) {
HXLINE( 116)					Float m = ::Std_obj::parseFloat(::format::svg::SVGData_obj::mMatrixMatch->matched(1));
HXLINE( 117)					Float m1 = ::Std_obj::parseFloat(::format::svg::SVGData_obj::mMatrixMatch->matched(2));
HXLINE( 118)					Float m2 = ::Std_obj::parseFloat(::format::svg::SVGData_obj::mMatrixMatch->matched(3));
HXLINE( 119)					Float m3 = ::Std_obj::parseFloat(::format::svg::SVGData_obj::mMatrixMatch->matched(4));
HXLINE( 120)					Float m4 = ::Std_obj::parseFloat(::format::svg::SVGData_obj::mMatrixMatch->matched(5));
HXLINE( 115)					 ::openfl::geom::Matrix m5 =  ::openfl::geom::Matrix_obj::__alloc( HX_CTX ,m,m1,m2,m3,m4,::Std_obj::parseFloat(::format::svg::SVGData_obj::mMatrixMatch->matched(6)));
HXLINE( 124)					m5->concat(ioMatrix);
HXLINE( 126)					ioMatrix->a = m5->a;
HXLINE( 127)					ioMatrix->b = m5->b;
HXLINE( 128)					ioMatrix->c = m5->c;
HXLINE( 129)					ioMatrix->d = m5->d;
HXLINE( 130)					ioMatrix->tx = m5->tx;
HXLINE( 131)					ioMatrix->ty = m5->ty;
HXLINE( 133)					scale = ::Math_obj::sqrt(((ioMatrix->a * ioMatrix->a) + (ioMatrix->c * ioMatrix->c)));
            				}
            				else {
HXLINE( 134)					if (::format::svg::SVGData_obj::mRotationMatch->match(inTrans)) {
HXLINE( 136)						Float degrees = ::Std_obj::parseFloat(::format::svg::SVGData_obj::mRotationMatch->matched(1));
HXLINE( 138)						Float rotationX = ::Std_obj::parseFloat(::format::svg::SVGData_obj::mRotationMatch->matched(2));
HXLINE( 139)						if (::Math_obj::isNaN(rotationX)) {
HXLINE( 140)							rotationX = ( (Float)(0) );
            						}
HXLINE( 142)						Float rotationY = ::Std_obj::parseFloat(::format::svg::SVGData_obj::mRotationMatch->matched(3));
HXLINE( 143)						if (::Math_obj::isNaN(rotationY)) {
HXLINE( 144)							rotationY = ( (Float)(0) );
            						}
HXLINE( 147)						Float radians = ((degrees * ::Math_obj::PI) / ( (Float)(180) ));
HXLINE( 149)						ioMatrix->translate(-(rotationX),-(rotationY));
HXLINE( 150)						ioMatrix->rotate(radians);
HXLINE( 151)						ioMatrix->translate(rotationX,rotationY);
            					}
            					else {
HXLINE( 154)						::haxe::Log_obj::trace((HX_("Warning, unknown transform:",d4,a9,19,e8) + inTrans),::hx::SourceInfo(HX_("format/svg/SVGData.hx",13,29,70,27),154,HX_("format.svg.SVGData",cd,22,af,06),HX_("applyTransform",1e,6a,11,34)));
            					}
            				}
            			}
            		}
HXLINE( 158)		return scale;
            	}


HX_DEFINE_DYNAMIC_FUNC2(SVGData_obj,applyTransform,return )

void SVGData_obj::dumpGroup( ::format::svg::Group g,::String indent){
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_163_dumpGroup)
HXLINE( 165)		::haxe::Log_obj::trace(((indent + HX_("Group:",3b,98,bc,50)) + g->name),::hx::SourceInfo(HX_("format/svg/SVGData.hx",13,29,70,27),165,HX_("format.svg.SVGData",cd,22,af,06),HX_("dumpGroup",6b,49,19,34)));
HXLINE( 166)		indent = (indent + HX_("  ",00,1c,00,00));
HXLINE( 168)		{
HXLINE( 168)			int _g = 0;
HXDLIN( 168)			::Array< ::Dynamic> _g1 = g->children;
HXDLIN( 168)			while((_g < _g1->length)){
HXLINE( 168)				 ::format::svg::DisplayElement e = _g1->__get(_g).StaticCast<  ::format::svg::DisplayElement >();
HXDLIN( 168)				_g = (_g + 1);
HXLINE( 170)				switch((int)(e->_hx_getIndex())){
            					case (int)0: {
HXLINE( 172)						 ::format::svg::Path path = e->_hx_getObject(0).StaticCast<  ::format::svg::Path >();
HXDLIN( 172)						 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN( 172)						::String _hx_tmp1 = (((indent + HX_("Path",c5,11,2b,35)) + HX_("  ",00,1c,00,00)) + ::Std_obj::string(path->matrix));
HXDLIN( 172)						_hx_tmp(_hx_tmp1,::hx::SourceInfo(HX_("format/svg/SVGData.hx",13,29,70,27),172,HX_("format.svg.SVGData",cd,22,af,06),HX_("dumpGroup",6b,49,19,34)));
            					}
            					break;
            					case (int)1: {
HXLINE( 173)						 ::format::svg::Group group = e->_hx_getObject(0).StaticCast<  ::format::svg::Group >();
HXDLIN( 173)						this->dumpGroup(group,(indent + HX_("   ",20,64,18,00)));
            					}
            					break;
            					case (int)2: {
HXLINE( 174)						 ::format::svg::Text text = e->_hx_getObject(0).StaticCast<  ::format::svg::Text >();
HXDLIN( 174)						::haxe::Log_obj::trace(((indent + HX_("Text ",b3,ba,c6,a0)) + text->text),::hx::SourceInfo(HX_("format/svg/SVGData.hx",13,29,70,27),174,HX_("format.svg.SVGData",cd,22,af,06),HX_("dumpGroup",6b,49,19,34)));
            					}
            					break;
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(SVGData_obj,dumpGroup,(void))

int SVGData_obj::getColorStyle(::String inKey, ::Xml inNode, ::haxe::ds::StringMap inStyles,int inDefault){
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_183_getColorStyle)
HXLINE( 185)		::String s = this->getStyle(inKey,inNode,inStyles,HX_("",00,00,00,00));
HXLINE( 187)		if ((s == HX_("",00,00,00,00))) {
HXLINE( 189)			return inDefault;
            		}
HXLINE( 193)		if ((s.charAt(0) == HX_("#",23,00,00,00))) {
HXLINE( 195)			::String hex = s.substr(1,null());
HXDLIN( 195)			if ((hex.length == 3)) {
HXLINE( 195)				::String hex1 = hex.substr(0,1);
HXDLIN( 195)				::String hex2 = (hex1 + hex.substr(0,1));
HXDLIN( 195)				::String hex3 = (hex2 + hex.substr(1,1));
HXDLIN( 195)				::String hex4 = (hex3 + hex.substr(1,1));
HXDLIN( 195)				::String hex5 = (hex4 + hex.substr(2,1));
HXDLIN( 195)				hex = (hex5 + hex.substr(2,1));
            			}
HXDLIN( 195)			return ( (int)(::Std_obj::parseInt((HX_("0x",48,2a,00,00) + hex))) );
            		}
HXLINE( 199)		if (::format::svg::SVGData_obj::mRGBMatch->match(s)) {
HXLINE( 201)			 ::EReg rgbMatch = ::format::svg::SVGData_obj::mRGBMatch;
HXDLIN( 201)			Float r = ::Std_obj::parseFloat(rgbMatch->matched(1));
HXDLIN( 201)			if ((rgbMatch->matched(2) == HX_("%",25,00,00,00))) {
HXLINE( 201)				r = ((r * ( (Float)(255) )) / ( (Float)(100) ));
            			}
HXDLIN( 201)			Float g = ::Std_obj::parseFloat(rgbMatch->matched(3));
HXDLIN( 201)			if ((rgbMatch->matched(4) == HX_("%",25,00,00,00))) {
HXLINE( 201)				g = ((g * ( (Float)(255) )) / ( (Float)(100) ));
            			}
HXDLIN( 201)			Float b = ::Std_obj::parseFloat(rgbMatch->matched(5));
HXDLIN( 201)			if ((rgbMatch->matched(6) == HX_("%",25,00,00,00))) {
HXLINE( 201)				b = ((b * ( (Float)(255) )) / ( (Float)(100) ));
            			}
HXDLIN( 201)			Float val = r;
HXDLIN( 201)			if ((val < 0)) {
HXLINE( 201)				val = ( (Float)(0) );
            			}
HXDLIN( 201)			if ((val > 255)) {
HXLINE( 201)				val = ( (Float)(255) );
            			}
HXDLIN( 201)			int _hx_tmp = (::Std_obj::_hx_int(val) << 16);
HXDLIN( 201)			Float val1 = g;
HXDLIN( 201)			if ((val1 < 0)) {
HXLINE( 201)				val1 = ( (Float)(0) );
            			}
HXDLIN( 201)			if ((val1 > 255)) {
HXLINE( 201)				val1 = ( (Float)(255) );
            			}
HXDLIN( 201)			int _hx_tmp1 = (_hx_tmp | (::Std_obj::_hx_int(val1) << 8));
HXDLIN( 201)			Float val2 = b;
HXDLIN( 201)			if ((val2 < 0)) {
HXLINE( 201)				val2 = ( (Float)(0) );
            			}
HXDLIN( 201)			if ((val2 > 255)) {
HXLINE( 201)				val2 = ( (Float)(255) );
            			}
HXDLIN( 201)			return (_hx_tmp1 | ::Std_obj::_hx_int(val2));
            		}
HXLINE( 205)		return ( (int)(::Std_obj::parseInt(s)) );
            	}


HX_DEFINE_DYNAMIC_FUNC4(SVGData_obj,getColorStyle,return )

 ::format::svg::FillType SVGData_obj::getFillStyle(::String inKey, ::Xml inNode, ::haxe::ds::StringMap inStyles){
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_210_getFillStyle)
HXLINE( 212)		::String s = this->getStyle(inKey,inNode,inStyles,HX_("",00,00,00,00));
HXLINE( 214)		if ((s == HX_("",00,00,00,00))) {
HXLINE( 216)			return ::format::svg::SVGData_obj::defaultFill;
            		}
HXLINE( 220)		if ((s.charAt(0) == HX_("#",23,00,00,00))) {
HXLINE( 222)			::String hex = s.substr(1,null());
HXDLIN( 222)			if ((hex.length == 3)) {
HXLINE( 222)				::String hex1 = hex.substr(0,1);
HXDLIN( 222)				::String hex2 = (hex1 + hex.substr(0,1));
HXDLIN( 222)				::String hex3 = (hex2 + hex.substr(1,1));
HXDLIN( 222)				::String hex4 = (hex3 + hex.substr(1,1));
HXDLIN( 222)				::String hex5 = (hex4 + hex.substr(2,1));
HXDLIN( 222)				hex = (hex5 + hex.substr(2,1));
            			}
HXDLIN( 222)			return ::format::svg::FillType_obj::FillSolid(( (int)(::Std_obj::parseInt((HX_("0x",48,2a,00,00) + hex))) ));
            		}
HXLINE( 226)		if (::format::svg::SVGData_obj::mRGBMatch->match(s)) {
HXLINE( 228)			 ::EReg rgbMatch = ::format::svg::SVGData_obj::mRGBMatch;
HXDLIN( 228)			Float r = ::Std_obj::parseFloat(rgbMatch->matched(1));
HXDLIN( 228)			if ((rgbMatch->matched(2) == HX_("%",25,00,00,00))) {
HXLINE( 228)				r = ((r * ( (Float)(255) )) / ( (Float)(100) ));
            			}
HXDLIN( 228)			Float g = ::Std_obj::parseFloat(rgbMatch->matched(3));
HXDLIN( 228)			if ((rgbMatch->matched(4) == HX_("%",25,00,00,00))) {
HXLINE( 228)				g = ((g * ( (Float)(255) )) / ( (Float)(100) ));
            			}
HXDLIN( 228)			Float b = ::Std_obj::parseFloat(rgbMatch->matched(5));
HXDLIN( 228)			if ((rgbMatch->matched(6) == HX_("%",25,00,00,00))) {
HXLINE( 228)				b = ((b * ( (Float)(255) )) / ( (Float)(100) ));
            			}
HXDLIN( 228)			Float val = r;
HXDLIN( 228)			if ((val < 0)) {
HXLINE( 228)				val = ( (Float)(0) );
            			}
HXDLIN( 228)			if ((val > 255)) {
HXLINE( 228)				val = ( (Float)(255) );
            			}
HXDLIN( 228)			int _hx_tmp = (::Std_obj::_hx_int(val) << 16);
HXDLIN( 228)			Float val1 = g;
HXDLIN( 228)			if ((val1 < 0)) {
HXLINE( 228)				val1 = ( (Float)(0) );
            			}
HXDLIN( 228)			if ((val1 > 255)) {
HXLINE( 228)				val1 = ( (Float)(255) );
            			}
HXDLIN( 228)			int _hx_tmp1 = (_hx_tmp | (::Std_obj::_hx_int(val1) << 8));
HXDLIN( 228)			Float val2 = b;
HXDLIN( 228)			if ((val2 < 0)) {
HXLINE( 228)				val2 = ( (Float)(0) );
            			}
HXDLIN( 228)			if ((val2 > 255)) {
HXLINE( 228)				val2 = ( (Float)(255) );
            			}
HXDLIN( 228)			return ::format::svg::FillType_obj::FillSolid((_hx_tmp1 | ::Std_obj::_hx_int(val2)));
            		}
HXLINE( 232)		if ((s == HX_("none",b8,12,0a,49))) {
HXLINE( 234)			return ::format::svg::FillType_obj::FillNone_dyn();
            		}
HXLINE( 238)		if (::format::svg::SVGData_obj::mURLMatch->match(s)) {
HXLINE( 240)			::String url = ::format::svg::SVGData_obj::mURLMatch->matched(1);
HXLINE( 242)			if (this->mGrads->exists(url)) {
HXLINE( 244)				return ::format::svg::FillType_obj::FillGrad(this->mGrads->get(url));
            			}
HXLINE( 248)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Unknown url:",61,7a,17,0e) + url)));
            		}
HXLINE( 252)		HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Unknown fill string:",22,66,f9,66) + s)));
HXDLIN( 252)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC3(SVGData_obj,getFillStyle,return )

Float SVGData_obj::getFloat( ::Xml inXML,::String inName,::hx::Null< Float >  __o_inDef){
            		Float inDef = __o_inDef.Default(((Float)0.0));
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_259_getFloat)
HXLINE( 261)		if (inXML->exists(inName)) {
HXLINE( 262)			return ::Std_obj::parseFloat(inXML->get(inName));
            		}
HXLINE( 264)		return inDef;
            	}


HX_DEFINE_DYNAMIC_FUNC3(SVGData_obj,getFloat,return )

Float SVGData_obj::getFloatStyle(::String inKey, ::Xml inNode, ::haxe::ds::StringMap inStyles,Float inDefault){
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_269_getFloatStyle)
HXLINE( 271)		::String s = this->getStyle(inKey,inNode,inStyles,HX_("",00,00,00,00));
HXLINE( 273)		if ((s == HX_("",00,00,00,00))) {
HXLINE( 275)			return inDefault;
            		}
HXLINE( 279)		return ::Std_obj::parseFloat(s);
            	}


HX_DEFINE_DYNAMIC_FUNC4(SVGData_obj,getFloatStyle,return )

 ::Dynamic SVGData_obj::getStyleAndConvert(::String inKey, ::Xml inNode, ::haxe::ds::StringMap inStyles, ::Dynamic inDefault, ::haxe::ds::StringMap inConvert){
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_284_getStyleAndConvert)
HXLINE( 286)		::String s = this->getStyle(inKey,inNode,inStyles,HX_("",00,00,00,00));
HXLINE( 288)		bool _hx_tmp;
HXDLIN( 288)		if ((s != HX_("",00,00,00,00))) {
HXLINE( 288)			_hx_tmp = !(inConvert->exists(s));
            		}
            		else {
HXLINE( 288)			_hx_tmp = true;
            		}
HXDLIN( 288)		if (_hx_tmp) {
HXLINE( 290)			return inDefault;
            		}
HXLINE( 294)		return inConvert->get(s);
            	}


HX_DEFINE_DYNAMIC_FUNC5(SVGData_obj,getStyleAndConvert,return )

 ::Dynamic SVGData_obj::getStrokeStyle(::String inKey, ::Xml inNode, ::haxe::ds::StringMap inStyles, ::Dynamic inDefault){
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_299_getStrokeStyle)
HXLINE( 301)		::String s = this->getStyle(inKey,inNode,inStyles,HX_("",00,00,00,00));
HXLINE( 303)		if ((s == HX_("",00,00,00,00))) {
HXLINE( 305)			return inDefault;
            		}
HXLINE( 310)		if (::format::svg::SVGData_obj::mRGBMatch->match(s)) {
HXLINE( 312)			 ::EReg rgbMatch = ::format::svg::SVGData_obj::mRGBMatch;
HXDLIN( 312)			Float r = ::Std_obj::parseFloat(rgbMatch->matched(1));
HXDLIN( 312)			if ((rgbMatch->matched(2) == HX_("%",25,00,00,00))) {
HXLINE( 312)				r = ((r * ( (Float)(255) )) / ( (Float)(100) ));
            			}
HXDLIN( 312)			Float g = ::Std_obj::parseFloat(rgbMatch->matched(3));
HXDLIN( 312)			if ((rgbMatch->matched(4) == HX_("%",25,00,00,00))) {
HXLINE( 312)				g = ((g * ( (Float)(255) )) / ( (Float)(100) ));
            			}
HXDLIN( 312)			Float b = ::Std_obj::parseFloat(rgbMatch->matched(5));
HXDLIN( 312)			if ((rgbMatch->matched(6) == HX_("%",25,00,00,00))) {
HXLINE( 312)				b = ((b * ( (Float)(255) )) / ( (Float)(100) ));
            			}
HXDLIN( 312)			Float val = r;
HXDLIN( 312)			if ((val < 0)) {
HXLINE( 312)				val = ( (Float)(0) );
            			}
HXDLIN( 312)			if ((val > 255)) {
HXLINE( 312)				val = ( (Float)(255) );
            			}
HXDLIN( 312)			int _hx_tmp = (::Std_obj::_hx_int(val) << 16);
HXDLIN( 312)			Float val1 = g;
HXDLIN( 312)			if ((val1 < 0)) {
HXLINE( 312)				val1 = ( (Float)(0) );
            			}
HXDLIN( 312)			if ((val1 > 255)) {
HXLINE( 312)				val1 = ( (Float)(255) );
            			}
HXDLIN( 312)			int _hx_tmp1 = (_hx_tmp | (::Std_obj::_hx_int(val1) << 8));
HXDLIN( 312)			Float val2 = b;
HXDLIN( 312)			if ((val2 < 0)) {
HXLINE( 312)				val2 = ( (Float)(0) );
            			}
HXDLIN( 312)			if ((val2 > 255)) {
HXLINE( 312)				val2 = ( (Float)(255) );
            			}
HXDLIN( 312)			return (_hx_tmp1 | ::Std_obj::_hx_int(val2));
            		}
HXLINE( 316)		if ((s == HX_("none",b8,12,0a,49))) {
HXLINE( 318)			return null();
            		}
HXLINE( 322)		if ((s.charAt(0) == HX_("#",23,00,00,00))) {
HXLINE( 324)			::String hex = s.substr(1,null());
HXDLIN( 324)			if ((hex.length == 3)) {
HXLINE( 324)				::String hex1 = hex.substr(0,1);
HXDLIN( 324)				::String hex2 = (hex1 + hex.substr(0,1));
HXDLIN( 324)				::String hex3 = (hex2 + hex.substr(1,1));
HXDLIN( 324)				::String hex4 = (hex3 + hex.substr(1,1));
HXDLIN( 324)				::String hex5 = (hex4 + hex.substr(2,1));
HXDLIN( 324)				hex = (hex5 + hex.substr(2,1));
            			}
HXDLIN( 324)			return ::Std_obj::parseInt((HX_("0x",48,2a,00,00) + hex));
            		}
HXLINE( 328)		return ::Std_obj::parseInt(s);
            	}


HX_DEFINE_DYNAMIC_FUNC4(SVGData_obj,getStrokeStyle,return )

::String SVGData_obj::getStyle(::String inKey, ::Xml inNode, ::haxe::ds::StringMap inStyles,::String inDefault){
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_333_getStyle)
HXLINE( 335)		bool _hx_tmp;
HXDLIN( 335)		if (::hx::IsNotNull( inNode )) {
HXLINE( 335)			_hx_tmp = inNode->exists(inKey);
            		}
            		else {
HXLINE( 335)			_hx_tmp = false;
            		}
HXDLIN( 335)		if (_hx_tmp) {
HXLINE( 337)			return inNode->get(inKey);
            		}
HXLINE( 341)		bool _hx_tmp1;
HXDLIN( 341)		if (::hx::IsNotNull( inStyles )) {
HXLINE( 341)			_hx_tmp1 = inStyles->exists(inKey);
            		}
            		else {
HXLINE( 341)			_hx_tmp1 = false;
            		}
HXDLIN( 341)		if (_hx_tmp1) {
HXLINE( 343)			return inStyles->get_string(inKey);
            		}
HXLINE( 347)		return inDefault;
            	}


HX_DEFINE_DYNAMIC_FUNC4(SVGData_obj,getStyle,return )

 ::haxe::ds::StringMap SVGData_obj::getStyles( ::Xml inNode, ::haxe::ds::StringMap inPrevStyles){
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_352_getStyles)
HXLINE( 354)		if (!(inNode->exists(HX_("style",31,a5,1d,84)))) {
HXLINE( 355)			return inPrevStyles;
            		}
HXLINE( 357)		 ::haxe::ds::StringMap styles =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE( 359)		if (::hx::IsNotNull( inPrevStyles )) {
HXLINE( 361)			 ::Dynamic s = inPrevStyles->keys();
HXDLIN( 361)			while(( (bool)(s->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 361)				::String s1 = ( (::String)(s->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 363)				styles->set(s1,inPrevStyles->get(s1));
            			}
            		}
HXLINE( 369)		::String style = inNode->get(HX_("style",31,a5,1d,84));
HXLINE( 370)		::Array< ::String > strings = ::format::svg::SVGData_obj::mStyleSplit->split(style);
HXLINE( 372)		{
HXLINE( 372)			int _g = 0;
HXDLIN( 372)			while((_g < strings->length)){
HXLINE( 372)				::String s = strings->__get(_g);
HXDLIN( 372)				_g = (_g + 1);
HXLINE( 374)				if (::format::svg::SVGData_obj::mStyleValue->match(s)) {
HXLINE( 376)					::String _hx_tmp = ::format::svg::SVGData_obj::mStyleValue->matched(1);
HXDLIN( 376)					styles->set(_hx_tmp,::format::svg::SVGData_obj::mStyleValue->matched(2));
            				}
            			}
            		}
HXLINE( 382)		return styles;
            	}


HX_DEFINE_DYNAMIC_FUNC2(SVGData_obj,getStyles,return )

void SVGData_obj::loadDefs( ::Xml inXML){
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_391_loadDefs)
HXLINE( 393)		{
HXLINE( 393)			 ::Dynamic def = inXML->elements();
HXDLIN( 393)			while(( (bool)(def->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 393)				 ::Xml def1 = ( ( ::Xml)(def->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 395)				if ((def1->nodeType != ::Xml_obj::Element)) {
HXLINE( 395)					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(def1->nodeType))));
            				}
HXDLIN( 395)				::String name = def1->nodeName;
HXLINE( 397)				if ((name.substr(0,4) == HX_("svg:",56,6d,5d,4c))) {
HXLINE( 399)					name = name.substr(4,null());
            				}
HXLINE( 403)				if ((name == HX_("linearGradient",f5,34,bd,a4))) {
HXLINE( 405)					this->loadGradient(def1,0,false);
            				}
            				else {
HXLINE( 407)					if ((name == HX_("radialGradient",ef,2b,20,87))) {
HXLINE( 409)						this->loadGradient(def1,1,false);
            					}
            				}
            			}
            		}
HXLINE( 393)		{
HXLINE( 393)			 ::Dynamic def1 = inXML->elements();
HXDLIN( 393)			while(( (bool)(def1->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 393)				 ::Xml def = ( ( ::Xml)(def1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 395)				if ((def->nodeType != ::Xml_obj::Element)) {
HXLINE( 395)					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(def->nodeType))));
            				}
HXDLIN( 395)				::String name = def->nodeName;
HXLINE( 397)				if ((name.substr(0,4) == HX_("svg:",56,6d,5d,4c))) {
HXLINE( 399)					name = name.substr(4,null());
            				}
HXLINE( 403)				if ((name == HX_("linearGradient",f5,34,bd,a4))) {
HXLINE( 405)					this->loadGradient(def,0,true);
            				}
            				else {
HXLINE( 407)					if ((name == HX_("radialGradient",ef,2b,20,87))) {
HXLINE( 409)						this->loadGradient(def,1,true);
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(SVGData_obj,loadDefs,(void))

void SVGData_obj::loadGradient( ::Xml inGrad, ::Dynamic inType,bool inCrossLink){
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_420_loadGradient)
HXLINE( 422)		::String name = inGrad->get(HX_("id",db,5b,00,00));
HXLINE( 423)		 ::format::svg::Grad grad =  ::format::svg::Grad_obj::__alloc( HX_CTX ,inType);
HXLINE( 425)		bool _hx_tmp;
HXDLIN( 425)		if (inCrossLink) {
HXLINE( 425)			_hx_tmp = inGrad->exists(HX_("xlink:href",73,9d,2c,e7));
            		}
            		else {
HXLINE( 425)			_hx_tmp = false;
            		}
HXDLIN( 425)		if (_hx_tmp) {
HXLINE( 427)			::String xlink = inGrad->get(HX_("xlink:href",73,9d,2c,e7));
HXLINE( 429)			if ((xlink.charAt(0) != HX_("#",23,00,00,00))) {
HXLINE( 430)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("xlink - unkown syntax : ",f8,f2,8e,0c) + xlink)));
            			}
HXLINE( 432)			 ::haxe::ds::StringMap base = this->mGrads;
HXDLIN( 432)			 ::format::svg::Grad base1 = ( ( ::format::svg::Grad)(base->get(xlink.substr(1,null()))) );
HXLINE( 434)			if (::hx::IsNotNull( base1 )) {
HXLINE( 436)				grad->colors = base1->colors;
HXLINE( 437)				grad->alphas = base1->alphas;
HXLINE( 438)				grad->ratios = base1->ratios;
HXLINE( 439)				grad->gradMatrix = base1->gradMatrix->clone();
HXLINE( 440)				grad->spread = base1->spread;
HXLINE( 441)				grad->interp = base1->interp;
HXLINE( 442)				grad->radius = base1->radius;
            			}
            			else {
HXLINE( 446)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Unknown xlink : ",0a,b1,e7,d8) + xlink)));
            			}
            		}
HXLINE( 452)		if (inGrad->exists(HX_("x1",b9,68,00,00))) {
HXLINE( 454)			grad->x1 = this->getFloat(inGrad,HX_("x1",b9,68,00,00),null());
HXLINE( 455)			grad->y1 = this->getFloat(inGrad,HX_("y1",98,69,00,00),null());
HXLINE( 456)			grad->x2 = this->getFloat(inGrad,HX_("x2",ba,68,00,00),null());
HXLINE( 457)			grad->y2 = this->getFloat(inGrad,HX_("y2",99,69,00,00),null());
            		}
            		else {
HXLINE( 461)			grad->x1 = this->getFloat(inGrad,HX_("cx",b5,56,00,00),null());
HXLINE( 462)			grad->y1 = this->getFloat(inGrad,HX_("cy",b6,56,00,00),null());
HXLINE( 463)			grad->x2 = this->getFloat(inGrad,HX_("fx",52,59,00,00),grad->x1);
HXLINE( 464)			grad->y2 = this->getFloat(inGrad,HX_("fy",53,59,00,00),grad->y1);
            		}
HXLINE( 468)		grad->radius = this->getFloat(inGrad,HX_("r",72,00,00,00),null());
HXLINE( 470)		if (inGrad->exists(HX_("gradientTransform",5c,15,c8,d7))) {
HXLINE( 472)			 ::openfl::geom::Matrix grad1 = grad->gradMatrix;
HXDLIN( 472)			this->applyTransform(grad1,inGrad->get(HX_("gradientTransform",5c,15,c8,d7)));
            		}
HXLINE( 478)		{
HXLINE( 478)			 ::Dynamic stop = inGrad->elements();
HXDLIN( 478)			while(( (bool)(stop->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 478)				 ::Xml stop1 = ( ( ::Xml)(stop->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 480)				 ::haxe::ds::StringMap styles = this->getStyles(stop1,null());
HXLINE( 482)				::Array< int > grad1 = grad->colors;
HXDLIN( 482)				grad1->push(this->getColorStyle(HX_("stop-color",98,8b,86,3d),stop1,styles,0));
HXLINE( 483)				::Array< Float > grad2 = grad->alphas;
HXDLIN( 483)				grad2->push(this->getFloatStyle(HX_("stop-opacity",40,2f,f2,90),stop1,styles,((Float)1.0)));
HXLINE( 484)				::Array< int > grad3 = grad->ratios;
HXDLIN( 484)				grad3->push(::Std_obj::_hx_int((::Std_obj::parseFloat(stop1->get(HX_("offset",93,97,3f,60))) * ((Float)255.0))));
            			}
            		}
HXLINE( 488)		this->mGrads->set(name,grad);
            	}


HX_DEFINE_DYNAMIC_FUNC3(SVGData_obj,loadGradient,(void))

 ::format::svg::Group SVGData_obj::loadGroup( ::format::svg::Group g, ::Xml inG, ::openfl::geom::Matrix matrix, ::haxe::ds::StringMap inStyles){
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_493_loadGroup)
HXLINE( 495)		if (inG->exists(HX_("transform",6c,2d,93,45))) {
HXLINE( 497)			matrix = matrix->clone();
HXLINE( 498)			this->applyTransform(matrix,inG->get(HX_("transform",6c,2d,93,45)));
            		}
HXLINE( 502)		if (inG->exists(HX_("inkscape:label",da,06,6b,89))) {
HXLINE( 504)			g->name = inG->get(HX_("inkscape:label",da,06,6b,89));
            		}
            		else {
HXLINE( 506)			if (inG->exists(HX_("id",db,5b,00,00))) {
HXLINE( 508)				g->name = inG->get(HX_("id",db,5b,00,00));
            			}
            		}
HXLINE( 512)		 ::haxe::ds::StringMap styles = this->getStyles(inG,inStyles);
HXLINE( 523)		if (inG->exists(HX_("opacity",cb,5d,65,eb))) {
HXLINE( 525)			::String opacity = inG->get(HX_("opacity",cb,5d,65,eb));
HXLINE( 527)			if (::hx::IsNull( styles )) {
HXLINE( 528)				styles =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            			}
HXLINE( 530)			if (styles->exists(HX_("opacity",cb,5d,65,eb))) {
HXLINE( 531)				Float opacity1 = ::Std_obj::parseFloat(opacity);
HXDLIN( 531)				opacity = ::Std_obj::string((opacity1 * ::Std_obj::parseFloat(styles->get_string(HX_("opacity",cb,5d,65,eb)))));
            			}
HXLINE( 533)			styles->set(HX_("opacity",cb,5d,65,eb),opacity);
            		}
HXLINE( 537)		{
HXLINE( 537)			 ::Dynamic el = inG->elements();
HXDLIN( 537)			while(( (bool)(el->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 537)				 ::Xml el1 = ( ( ::Xml)(el->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 539)				if ((el1->nodeType != ::Xml_obj::Element)) {
HXLINE( 539)					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(el1->nodeType))));
            				}
HXDLIN( 539)				::String name = el1->nodeName;
HXLINE( 541)				if ((name.substr(0,4) == HX_("svg:",56,6d,5d,4c))) {
HXLINE( 543)					name = name.substr(4,null());
            				}
HXLINE( 547)				bool _hx_tmp;
HXDLIN( 547)				if (el1->exists(HX_("display",42,2a,4a,bb))) {
HXLINE( 547)					_hx_tmp = (el1->get(HX_("display",42,2a,4a,bb)) == HX_("none",b8,12,0a,49));
            				}
            				else {
HXLINE( 547)					_hx_tmp = false;
            				}
HXDLIN( 547)				if (_hx_tmp) {
HXLINE( 547)					continue;
            				}
HXLINE( 549)				if ((name == HX_("defs",0e,53,66,42))) {
HXLINE( 551)					this->loadDefs(el1);
            				}
            				else {
HXLINE( 553)					if ((name == HX_("g",67,00,00,00))) {
HXLINE( 555)						bool _hx_tmp;
HXDLIN( 555)						if (el1->exists(HX_("display",42,2a,4a,bb))) {
HXLINE( 555)							_hx_tmp = (el1->get(HX_("display",42,2a,4a,bb)) == HX_("none",b8,12,0a,49));
            						}
            						else {
HXLINE( 555)							_hx_tmp = false;
            						}
HXDLIN( 555)						if (!(_hx_tmp)) {
HXLINE( 557)							::Array< ::Dynamic> g1 = g->children;
HXDLIN( 557)							g1->push(::format::svg::DisplayElement_obj::DisplayGroup(this->loadGroup( ::format::svg::Group_obj::__alloc( HX_CTX ),el1,matrix,styles)));
            						}
            					}
            					else {
HXLINE( 561)						bool _hx_tmp;
HXDLIN( 561)						bool _hx_tmp1;
HXDLIN( 561)						if ((name != HX_("path",a5,e5,51,4a))) {
HXLINE( 561)							_hx_tmp1 = (name == HX_("line",f4,17,b3,47));
            						}
            						else {
HXLINE( 561)							_hx_tmp1 = true;
            						}
HXDLIN( 561)						if (!(_hx_tmp1)) {
HXLINE( 561)							_hx_tmp = (name == HX_("polyline",40,ac,9a,2f));
            						}
            						else {
HXLINE( 561)							_hx_tmp = true;
            						}
HXDLIN( 561)						if (_hx_tmp) {
HXLINE( 563)							::Array< ::Dynamic> g1 = g->children;
HXDLIN( 563)							g1->push(::format::svg::DisplayElement_obj::DisplayPath(this->loadPath(el1,matrix,styles,false,false,null())));
            						}
            						else {
HXLINE( 565)							if ((name == HX_("rect",24,4d,a7,4b))) {
HXLINE( 567)								::Array< ::Dynamic> g1 = g->children;
HXDLIN( 567)								g1->push(::format::svg::DisplayElement_obj::DisplayPath(this->loadPath(el1,matrix,styles,true,false,null())));
            							}
            							else {
HXLINE( 569)								if ((name == HX_("polygon",7a,02,91,12))) {
HXLINE( 571)									::Array< ::Dynamic> g1 = g->children;
HXDLIN( 571)									g1->push(::format::svg::DisplayElement_obj::DisplayPath(this->loadPath(el1,matrix,styles,false,false,null())));
            								}
            								else {
HXLINE( 573)									if ((name == HX_("ellipse",de,40,86,0b))) {
HXLINE( 575)										::Array< ::Dynamic> g1 = g->children;
HXDLIN( 575)										g1->push(::format::svg::DisplayElement_obj::DisplayPath(this->loadPath(el1,matrix,styles,false,true,null())));
            									}
            									else {
HXLINE( 577)										if ((name == HX_("circle",10,72,0d,56))) {
HXLINE( 579)											::Array< ::Dynamic> g1 = g->children;
HXDLIN( 579)											g1->push(::format::svg::DisplayElement_obj::DisplayPath(this->loadPath(el1,matrix,styles,false,true,true)));
            										}
            										else {
HXLINE( 581)											if ((name == HX_("text",ad,cc,f9,4c))) {
HXLINE( 583)												::Array< ::Dynamic> g1 = g->children;
HXDLIN( 583)												g1->push(::format::svg::DisplayElement_obj::DisplayText(this->loadText(el1,matrix,styles)));
            											}
            											else {
HXLINE( 585)												if ((name == HX_("linearGradient",f5,34,bd,a4))) {
HXLINE( 587)													this->loadGradient(el1,0,true);
            												}
            												else {
HXLINE( 589)													if ((name == HX_("radialGradient",ef,2b,20,87))) {
HXLINE( 591)														this->loadGradient(el1,1,true);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 601)		return g;
            	}


HX_DEFINE_DYNAMIC_FUNC4(SVGData_obj,loadGroup,return )

 ::format::svg::Path SVGData_obj::loadPath( ::Xml inPath, ::openfl::geom::Matrix matrix, ::haxe::ds::StringMap inStyles,bool inIsRect,bool inIsEllipse,::hx::Null< bool >  __o_inIsCircle){
            		bool inIsCircle = __o_inIsCircle.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_606_loadPath)
HXLINE( 608)		if (inPath->exists(HX_("transform",6c,2d,93,45))) {
HXLINE( 610)			matrix = matrix->clone();
HXLINE( 611)			this->applyTransform(matrix,inPath->get(HX_("transform",6c,2d,93,45)));
            		}
HXLINE( 615)		 ::haxe::ds::StringMap styles = this->getStyles(inPath,inStyles);
HXLINE( 616)		::String name;
HXDLIN( 616)		if (inPath->exists(HX_("id",db,5b,00,00))) {
HXLINE( 616)			name = inPath->get(HX_("id",db,5b,00,00));
            		}
            		else {
HXLINE( 616)			name = HX_("",00,00,00,00);
            		}
HXLINE( 617)		 ::format::svg::Path path =  ::format::svg::Path_obj::__alloc( HX_CTX );
HXLINE( 619)		path->fill = this->getFillStyle(HX_("fill",83,ce,bb,43),inPath,styles);
HXLINE( 620)		path->alpha = this->getFloatStyle(HX_("opacity",cb,5d,65,eb),inPath,styles,((Float)1.0));
HXLINE( 621)		path->fill_alpha = this->getFloatStyle(HX_("fill-opacity",c1,f6,05,24),inPath,styles,((Float)1.0));
HXLINE( 622)		path->stroke_alpha = this->getFloatStyle(HX_("stroke-opacity",f6,98,66,c8),inPath,styles,((Float)1.0));
HXLINE( 623)		path->stroke_colour = this->getStrokeStyle(HX_("stroke",b8,b3,34,11),inPath,styles,null());
HXLINE( 624)		path->stroke_width = this->getFloatStyle(HX_("stroke-width",71,40,1c,1e),inPath,styles,((Float)1.0));
HXLINE( 626)		 ::haxe::ds::StringMap _g =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN( 626)		_g->set(HX_("round",4e,f8,65,ed),1);
HXDLIN( 626)		_g->set(HX_("square",9d,00,f2,58),2);
HXDLIN( 626)		_g->set(HX_("butt",13,16,20,41),0);
HXLINE( 625)		path->stroke_caps = this->getStyleAndConvert(HX_("stroke-linecap",c9,07,aa,fc),inPath,styles,0,_g);
HXLINE( 628)		 ::haxe::ds::StringMap _g1 =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN( 628)		_g1->set(HX_("bevel",7a,48,61,b0),0);
HXDLIN( 628)		_g1->set(HX_("round",4e,f8,65,ed),2);
HXDLIN( 628)		_g1->set(HX_("miter",05,00,6d,08),1);
HXLINE( 627)		path->joint_style = this->getStyleAndConvert(HX_("stroke-linejoin",53,e0,c7,1c),inPath,styles,1,_g1);
HXLINE( 629)		path->miter_limit = this->getFloatStyle(HX_("stroke-miterlimit",cb,be,de,56),inPath,styles,((Float)3.0));
HXLINE( 630)		path->segments = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 631)		path->matrix = matrix;
HXLINE( 632)		path->name = name;
HXLINE( 634)		if (inIsRect) {
HXLINE( 636)			Float x;
HXDLIN( 636)			if (inPath->exists(HX_("x",78,00,00,00))) {
HXLINE( 636)				x = ::Std_obj::parseFloat(inPath->get(HX_("x",78,00,00,00)));
            			}
            			else {
HXLINE( 636)				x = ( (Float)(0) );
            			}
HXLINE( 637)			Float y;
HXDLIN( 637)			if (inPath->exists(HX_("y",79,00,00,00))) {
HXLINE( 637)				y = ::Std_obj::parseFloat(inPath->get(HX_("y",79,00,00,00)));
            			}
            			else {
HXLINE( 637)				y = ( (Float)(0) );
            			}
HXLINE( 638)			Float w = ::Std_obj::parseFloat(inPath->get(HX_("width",06,b6,62,ca)));
HXLINE( 639)			Float h = ::Std_obj::parseFloat(inPath->get(HX_("height",e7,07,4c,02)));
HXLINE( 640)			Float rx;
HXDLIN( 640)			if (inPath->exists(HX_("rx",c6,63,00,00))) {
HXLINE( 640)				rx = ::Std_obj::parseFloat(inPath->get(HX_("rx",c6,63,00,00)));
            			}
            			else {
HXLINE( 640)				rx = ((Float)0.0);
            			}
HXLINE( 641)			Float ry;
HXDLIN( 641)			if (inPath->exists(HX_("ry",c7,63,00,00))) {
HXLINE( 641)				ry = ::Std_obj::parseFloat(inPath->get(HX_("ry",c7,63,00,00)));
            			}
            			else {
HXLINE( 641)				ry = ((Float)0.0);
            			}
HXLINE( 643)			bool _hx_tmp;
HXDLIN( 643)			if ((rx != 0)) {
HXLINE( 643)				_hx_tmp = (ry == 0);
            			}
            			else {
HXLINE( 643)				_hx_tmp = true;
            			}
HXDLIN( 643)			if (_hx_tmp) {
HXLINE( 645)				::Array< ::Dynamic> path1 = path->segments;
HXDLIN( 645)				path1->push( ::format::svg::MoveSegment_obj::__alloc( HX_CTX ,x,y));
HXLINE( 646)				::Array< ::Dynamic> path2 = path->segments;
HXDLIN( 646)				path2->push( ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,(x + w),y));
HXLINE( 647)				::Array< ::Dynamic> path3 = path->segments;
HXDLIN( 647)				path3->push( ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,(x + w),(y + h)));
HXLINE( 648)				::Array< ::Dynamic> path4 = path->segments;
HXDLIN( 648)				path4->push( ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,x,(y + h)));
HXLINE( 649)				::Array< ::Dynamic> path5 = path->segments;
HXDLIN( 649)				path5->push( ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,x,y));
            			}
            			else {
HXLINE( 653)				::Array< ::Dynamic> path1 = path->segments;
HXDLIN( 653)				path1->push( ::format::svg::MoveSegment_obj::__alloc( HX_CTX ,x,(y + ry)));
HXLINE( 656)				::Array< ::Dynamic> path2 = path->segments;
HXDLIN( 656)				path2->push( ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,x,y,(x + rx),y));
HXLINE( 657)				::Array< ::Dynamic> path3 = path->segments;
HXDLIN( 657)				path3->push( ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,((x + w) - rx),y));
HXLINE( 660)				::Array< ::Dynamic> path4 = path->segments;
HXDLIN( 660)				path4->push( ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,(x + w),y,(x + w),(y + rx)));
HXLINE( 661)				::Array< ::Dynamic> path5 = path->segments;
HXDLIN( 661)				path5->push( ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,(x + w),((y + h) - ry)));
HXLINE( 664)				::Array< ::Dynamic> path6 = path->segments;
HXDLIN( 664)				path6->push( ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,(x + w),(y + h),((x + w) - rx),(y + h)));
HXLINE( 665)				::Array< ::Dynamic> path7 = path->segments;
HXDLIN( 665)				path7->push( ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,(x + rx),(y + h)));
HXLINE( 668)				::Array< ::Dynamic> path8 = path->segments;
HXDLIN( 668)				path8->push( ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,x,(y + h),x,((y + h) - ry)));
HXLINE( 669)				::Array< ::Dynamic> path9 = path->segments;
HXDLIN( 669)				path9->push( ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,x,(y + ry)));
            			}
            		}
            		else {
HXLINE( 673)			if (inIsEllipse) {
HXLINE( 675)				Float x;
HXDLIN( 675)				if (inPath->exists(HX_("cx",b5,56,00,00))) {
HXLINE( 675)					x = ::Std_obj::parseFloat(inPath->get(HX_("cx",b5,56,00,00)));
            				}
            				else {
HXLINE( 675)					x = ( (Float)(0) );
            				}
HXLINE( 676)				Float y;
HXDLIN( 676)				if (inPath->exists(HX_("cy",b6,56,00,00))) {
HXLINE( 676)					y = ::Std_obj::parseFloat(inPath->get(HX_("cy",b6,56,00,00)));
            				}
            				else {
HXLINE( 676)					y = ( (Float)(0) );
            				}
HXLINE( 677)				Float r;
HXDLIN( 677)				bool r1;
HXDLIN( 677)				if (inIsCircle) {
HXLINE( 677)					r1 = inPath->exists(HX_("r",72,00,00,00));
            				}
            				else {
HXLINE( 677)					r1 = false;
            				}
HXDLIN( 677)				if (r1) {
HXLINE( 677)					r = ::Std_obj::parseFloat(inPath->get(HX_("r",72,00,00,00)));
            				}
            				else {
HXLINE( 677)					r = ((Float)0.0);
            				}
HXLINE( 678)				Float w;
HXDLIN( 678)				if (inIsCircle) {
HXLINE( 678)					w = r;
            				}
            				else {
HXLINE( 678)					if (inPath->exists(HX_("rx",c6,63,00,00))) {
HXLINE( 678)						w = ::Std_obj::parseFloat(inPath->get(HX_("rx",c6,63,00,00)));
            					}
            					else {
HXLINE( 678)						w = ((Float)0.0);
            					}
            				}
HXLINE( 679)				Float w_ = (w * ((Float)0.70710678118654752440084436210485));
HXLINE( 680)				Float cw_ = (w * ((Float)0.4142135623730950488016887242097));
HXLINE( 681)				Float h;
HXDLIN( 681)				if (inIsCircle) {
HXLINE( 681)					h = r;
            				}
            				else {
HXLINE( 681)					if (inPath->exists(HX_("ry",c7,63,00,00))) {
HXLINE( 681)						h = ::Std_obj::parseFloat(inPath->get(HX_("ry",c7,63,00,00)));
            					}
            					else {
HXLINE( 681)						h = ((Float)0.0);
            					}
            				}
HXLINE( 682)				Float h_ = (h * ((Float)0.70710678118654752440084436210485));
HXLINE( 683)				Float ch_ = (h * ((Float)0.4142135623730950488016887242097));
HXLINE( 685)				::Array< ::Dynamic> path1 = path->segments;
HXDLIN( 685)				path1->push( ::format::svg::MoveSegment_obj::__alloc( HX_CTX ,(x + w),y));
HXLINE( 686)				::Array< ::Dynamic> path2 = path->segments;
HXDLIN( 686)				path2->push( ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,(x + w),(y + ch_),(x + w_),(y + h_)));
HXLINE( 687)				::Array< ::Dynamic> path3 = path->segments;
HXDLIN( 687)				path3->push( ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,(x + cw_),(y + h),x,(y + h)));
HXLINE( 688)				::Array< ::Dynamic> path4 = path->segments;
HXDLIN( 688)				path4->push( ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,(x - cw_),(y + h),(x - w_),(y + h_)));
HXLINE( 689)				::Array< ::Dynamic> path5 = path->segments;
HXDLIN( 689)				path5->push( ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,(x - w),(y + ch_),(x - w),y));
HXLINE( 690)				::Array< ::Dynamic> path6 = path->segments;
HXDLIN( 690)				path6->push( ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,(x - w),(y - ch_),(x - w_),(y - h_)));
HXLINE( 691)				::Array< ::Dynamic> path7 = path->segments;
HXDLIN( 691)				path7->push( ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,(x - cw_),(y - h),x,(y - h)));
HXLINE( 692)				::Array< ::Dynamic> path8 = path->segments;
HXDLIN( 692)				path8->push( ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,(x + cw_),(y - h),(x + w_),(y - h_)));
HXLINE( 693)				::Array< ::Dynamic> path9 = path->segments;
HXDLIN( 693)				path9->push( ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,(x + w),(y - ch_),(x + w),y));
            			}
            			else {
HXLINE( 697)				::String d;
HXDLIN( 697)				if (inPath->exists(HX_("points",23,12,2e,f7))) {
HXLINE( 697)					d = ((HX_("M",4d,00,00,00) + inPath->get(HX_("points",23,12,2e,f7))) + HX_("z",7a,00,00,00));
            				}
            				else {
HXLINE( 698)					if (inPath->exists(HX_("x1",b9,68,00,00))) {
HXLINE( 698)						::String d1 = ((HX_("M",4d,00,00,00) + inPath->get(HX_("x1",b9,68,00,00))) + HX_(",",2c,00,00,00));
HXDLIN( 698)						::String d2 = ((d1 + inPath->get(HX_("y1",98,69,00,00))) + HX_(" ",20,00,00,00));
HXDLIN( 698)						::String d3 = ((d2 + inPath->get(HX_("x2",ba,68,00,00))) + HX_(",",2c,00,00,00));
HXLINE( 697)						d = ((d3 + inPath->get(HX_("y2",99,69,00,00))) + HX_("z",7a,00,00,00));
            					}
            					else {
HXLINE( 697)						d = inPath->get(HX_("d",64,00,00,00));
            					}
            				}
HXLINE( 701)				{
HXLINE( 701)					int _g = 0;
HXDLIN( 701)					::Array< ::Dynamic> _g1 = this->mPathParser->parse(d,this->mConvertCubics);
HXDLIN( 701)					while((_g < _g1->length)){
HXLINE( 701)						 ::format::svg::PathSegment segment = _g1->__get(_g).StaticCast<  ::format::svg::PathSegment >();
HXDLIN( 701)						_g = (_g + 1);
HXLINE( 703)						path->segments->push(segment);
            					}
            				}
            			}
            		}
HXLINE( 709)		return path;
            	}


HX_DEFINE_DYNAMIC_FUNC6(SVGData_obj,loadPath,return )

 ::format::svg::Text SVGData_obj::loadText( ::Xml inText, ::openfl::geom::Matrix matrix, ::haxe::ds::StringMap inStyles){
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_714_loadText)
HXLINE( 716)		if (inText->exists(HX_("transform",6c,2d,93,45))) {
HXLINE( 718)			matrix = matrix->clone();
HXLINE( 719)			this->applyTransform(matrix,inText->get(HX_("transform",6c,2d,93,45)));
            		}
HXLINE( 723)		 ::haxe::ds::StringMap styles = this->getStyles(inText,inStyles);
HXLINE( 724)		 ::format::svg::Text text =  ::format::svg::Text_obj::__alloc( HX_CTX );
HXLINE( 726)		text->matrix = matrix;
HXLINE( 727)		::String _hx_tmp;
HXDLIN( 727)		if (inText->exists(HX_("id",db,5b,00,00))) {
HXLINE( 727)			_hx_tmp = inText->get(HX_("id",db,5b,00,00));
            		}
            		else {
HXLINE( 727)			_hx_tmp = HX_("",00,00,00,00);
            		}
HXDLIN( 727)		text->name = _hx_tmp;
HXLINE( 728)		text->x = this->getFloat(inText,HX_("x",78,00,00,00),((Float)0.0));
HXLINE( 729)		text->y = this->getFloat(inText,HX_("y",79,00,00,00),((Float)0.0));
HXLINE( 730)		text->fill = this->getFillStyle(HX_("fill",83,ce,bb,43),inText,styles);
HXLINE( 731)		text->fill_alpha = this->getFloatStyle(HX_("fill-opacity",c1,f6,05,24),inText,styles,((Float)1.0));
HXLINE( 732)		text->stroke_alpha = this->getFloatStyle(HX_("stroke-opacity",f6,98,66,c8),inText,styles,((Float)1.0));
HXLINE( 733)		text->stroke_colour = this->getStrokeStyle(HX_("stroke",b8,b3,34,11),inText,styles,null());
HXLINE( 734)		text->stroke_width = this->getFloatStyle(HX_("stroke-width",71,40,1c,1e),inText,styles,((Float)1.0));
HXLINE( 735)		text->font_family = this->getStyle(HX_("font-family",a2,c9,66,81),inText,styles,HX_("",00,00,00,00));
HXLINE( 736)		text->font_size = this->getFloatStyle(HX_("font-size",3f,ef,09,4e),inText,styles,( (Float)(12) ));
HXLINE( 737)		text->letter_spacing = this->getFloatStyle(HX_("letter-spacing",dc,45,12,42),inText,styles,( (Float)(0) ));
HXLINE( 738)		text->kerning = this->getFloatStyle(HX_("kerning",cc,ba,37,b0),inText,styles,( (Float)(0) ));
HXLINE( 739)		text->text_align = this->getStyle(HX_("text-align",e5,9f,fc,21),inText,styles,HX_("start",62,74,0b,84));
HXLINE( 741)		::String string = HX_("",00,00,00,00);
HXLINE( 743)		{
HXLINE( 743)			 ::Dynamic el = inText->elements();
HXDLIN( 743)			while(( (bool)(el->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 743)				 ::Xml el1 = ( ( ::Xml)(el->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 745)				string = (string + ::haxe::xml::Printer_obj::print(el1,null()));
            			}
            		}
HXLINE( 750)		text->text = string;
HXLINE( 751)		return text;
            	}


HX_DEFINE_DYNAMIC_FUNC3(SVGData_obj,loadText,return )

Float SVGData_obj::SIN45;

Float SVGData_obj::TAN22;

 ::EReg SVGData_obj::mStyleSplit;

 ::EReg SVGData_obj::mStyleValue;

 ::EReg SVGData_obj::mTranslateMatch;

 ::EReg SVGData_obj::mScaleMatch;

 ::EReg SVGData_obj::mMatrixMatch;

 ::EReg SVGData_obj::mRotationMatch;

 ::EReg SVGData_obj::mURLMatch;

 ::EReg SVGData_obj::mRGBMatch;

 ::format::svg::FillType SVGData_obj::defaultFill;

int SVGData_obj::parseHex(::String hex){
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_756_parseHex)
HXLINE( 759)		if ((hex.length == 3)) {
HXLINE( 760)			::String hex1 = hex.substr(0,1);
HXDLIN( 760)			::String hex2 = (hex1 + hex.substr(0,1));
HXDLIN( 760)			::String hex3 = (hex2 + hex.substr(1,1));
HXDLIN( 760)			::String hex4 = (hex3 + hex.substr(1,1));
HXDLIN( 760)			::String hex5 = (hex4 + hex.substr(2,1));
HXDLIN( 760)			hex = (hex5 + hex.substr(2,1));
            		}
HXLINE( 765)		return ( (int)(::Std_obj::parseInt((HX_("0x",48,2a,00,00) + hex))) );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(SVGData_obj,parseHex,return )

int SVGData_obj::parseRGBMatch( ::EReg rgbMatch){
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_769_parseRGBMatch)
HXLINE( 780)		Float r = ::Std_obj::parseFloat(rgbMatch->matched(1));
HXLINE( 781)		if ((rgbMatch->matched(2) == HX_("%",25,00,00,00))) {
HXLINE( 781)			r = ((r * ( (Float)(255) )) / ( (Float)(100) ));
            		}
HXLINE( 783)		Float g = ::Std_obj::parseFloat(rgbMatch->matched(3));
HXLINE( 784)		if ((rgbMatch->matched(4) == HX_("%",25,00,00,00))) {
HXLINE( 784)			g = ((g * ( (Float)(255) )) / ( (Float)(100) ));
            		}
HXLINE( 786)		Float b = ::Std_obj::parseFloat(rgbMatch->matched(5));
HXLINE( 787)		if ((rgbMatch->matched(6) == HX_("%",25,00,00,00))) {
HXLINE( 787)			b = ((b * ( (Float)(255) )) / ( (Float)(100) ));
            		}
HXLINE( 789)		Float val = r;
HXDLIN( 789)		if ((val < 0)) {
HXLINE( 789)			val = ( (Float)(0) );
            		}
HXDLIN( 789)		if ((val > 255)) {
HXLINE( 789)			val = ( (Float)(255) );
            		}
HXDLIN( 789)		int _hx_tmp = (::Std_obj::_hx_int(val) << 16);
HXDLIN( 789)		Float val1 = g;
HXDLIN( 789)		if ((val1 < 0)) {
HXLINE( 789)			val1 = ( (Float)(0) );
            		}
HXDLIN( 789)		if ((val1 > 255)) {
HXLINE( 789)			val1 = ( (Float)(255) );
            		}
HXDLIN( 789)		int _hx_tmp1 = (_hx_tmp | (::Std_obj::_hx_int(val1) << 8));
HXDLIN( 789)		Float val2 = b;
HXDLIN( 789)		if ((val2 < 0)) {
HXLINE( 789)			val2 = ( (Float)(0) );
            		}
HXDLIN( 789)		if ((val2 > 255)) {
HXLINE( 789)			val2 = ( (Float)(255) );
            		}
HXDLIN( 789)		return (_hx_tmp1 | ::Std_obj::_hx_int(val2));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(SVGData_obj,parseRGBMatch,return )


::hx::ObjectPtr< SVGData_obj > SVGData_obj::__new( ::Xml inXML,::hx::Null< bool >  __o_inConvertCubics) {
	::hx::ObjectPtr< SVGData_obj > __this = new SVGData_obj();
	__this->__construct(inXML,__o_inConvertCubics);
	return __this;
}

::hx::ObjectPtr< SVGData_obj > SVGData_obj::__alloc(::hx::Ctx *_hx_ctx, ::Xml inXML,::hx::Null< bool >  __o_inConvertCubics) {
	SVGData_obj *__this = (SVGData_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(SVGData_obj), true, "format.svg.SVGData"));
	*(void **)__this = SVGData_obj::_hx_vtable;
	__this->__construct(inXML,__o_inConvertCubics);
	return __this;
}

SVGData_obj::SVGData_obj()
{
}

void SVGData_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(SVGData);
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(mConvertCubics,"mConvertCubics");
	HX_MARK_MEMBER_NAME(mGrads,"mGrads");
	HX_MARK_MEMBER_NAME(mPathParser,"mPathParser");
	 ::format::svg::Group_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void SVGData_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(mConvertCubics,"mConvertCubics");
	HX_VISIT_MEMBER_NAME(mGrads,"mGrads");
	HX_VISIT_MEMBER_NAME(mPathParser,"mPathParser");
	 ::format::svg::Group_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val SVGData_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		if (HX_FIELD_EQ(inName,"mGrads") ) { return ::hx::Val( mGrads ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"getFloat") ) { return ::hx::Val( getFloat_dyn() ); }
		if (HX_FIELD_EQ(inName,"getStyle") ) { return ::hx::Val( getStyle_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadDefs") ) { return ::hx::Val( loadDefs_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadPath") ) { return ::hx::Val( loadPath_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadText") ) { return ::hx::Val( loadText_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"dumpGroup") ) { return ::hx::Val( dumpGroup_dyn() ); }
		if (HX_FIELD_EQ(inName,"getStyles") ) { return ::hx::Val( getStyles_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadGroup") ) { return ::hx::Val( loadGroup_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"mPathParser") ) { return ::hx::Val( mPathParser ); }
		if (HX_FIELD_EQ(inName,"trimToFloat") ) { return ::hx::Val( trimToFloat_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"getFillStyle") ) { return ::hx::Val( getFillStyle_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadGradient") ) { return ::hx::Val( loadGradient_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getColorStyle") ) { return ::hx::Val( getColorStyle_dyn() ); }
		if (HX_FIELD_EQ(inName,"getFloatStyle") ) { return ::hx::Val( getFloatStyle_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"mConvertCubics") ) { return ::hx::Val( mConvertCubics ); }
		if (HX_FIELD_EQ(inName,"applyTransform") ) { return ::hx::Val( applyTransform_dyn() ); }
		if (HX_FIELD_EQ(inName,"getStrokeStyle") ) { return ::hx::Val( getStrokeStyle_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"getStyleAndConvert") ) { return ::hx::Val( getStyleAndConvert_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool SVGData_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"parseHex") ) { outValue = parseHex_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"mURLMatch") ) { outValue = ( mURLMatch ); return true; }
		if (HX_FIELD_EQ(inName,"mRGBMatch") ) { outValue = ( mRGBMatch ); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"mStyleSplit") ) { outValue = ( mStyleSplit ); return true; }
		if (HX_FIELD_EQ(inName,"mStyleValue") ) { outValue = ( mStyleValue ); return true; }
		if (HX_FIELD_EQ(inName,"mScaleMatch") ) { outValue = ( mScaleMatch ); return true; }
		if (HX_FIELD_EQ(inName,"defaultFill") ) { outValue = ( defaultFill ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"mMatrixMatch") ) { outValue = ( mMatrixMatch ); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"parseRGBMatch") ) { outValue = parseRGBMatch_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"mRotationMatch") ) { outValue = ( mRotationMatch ); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"mTranslateMatch") ) { outValue = ( mTranslateMatch ); return true; }
	}
	return false;
}

::hx::Val SVGData_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"mGrads") ) { mGrads=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"mPathParser") ) { mPathParser=inValue.Cast<  ::format::svg::PathParser >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"mConvertCubics") ) { mConvertCubics=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool SVGData_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"mURLMatch") ) { mURLMatch=ioValue.Cast<  ::EReg >(); return true; }
		if (HX_FIELD_EQ(inName,"mRGBMatch") ) { mRGBMatch=ioValue.Cast<  ::EReg >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"mStyleSplit") ) { mStyleSplit=ioValue.Cast<  ::EReg >(); return true; }
		if (HX_FIELD_EQ(inName,"mStyleValue") ) { mStyleValue=ioValue.Cast<  ::EReg >(); return true; }
		if (HX_FIELD_EQ(inName,"mScaleMatch") ) { mScaleMatch=ioValue.Cast<  ::EReg >(); return true; }
		if (HX_FIELD_EQ(inName,"defaultFill") ) { defaultFill=ioValue.Cast<  ::format::svg::FillType >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"mMatrixMatch") ) { mMatrixMatch=ioValue.Cast<  ::EReg >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"mRotationMatch") ) { mRotationMatch=ioValue.Cast<  ::EReg >(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"mTranslateMatch") ) { mTranslateMatch=ioValue.Cast<  ::EReg >(); return true; }
	}
	return false;
}

void SVGData_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("mConvertCubics",8f,3d,64,9b));
	outFields->push(HX_("mGrads",38,c9,fd,c1));
	outFields->push(HX_("mPathParser",31,ef,22,d5));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo SVGData_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(SVGData_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsFloat,(int)offsetof(SVGData_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsBool,(int)offsetof(SVGData_obj,mConvertCubics),HX_("mConvertCubics",8f,3d,64,9b)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(SVGData_obj,mGrads),HX_("mGrads",38,c9,fd,c1)},
	{::hx::fsObject /*  ::format::svg::PathParser */ ,(int)offsetof(SVGData_obj,mPathParser),HX_("mPathParser",31,ef,22,d5)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo SVGData_obj_sStaticStorageInfo[] = {
	{::hx::fsFloat,(void *) &SVGData_obj::SIN45,HX_("SIN45",79,16,be,fa)},
	{::hx::fsFloat,(void *) &SVGData_obj::TAN22,HX_("TAN22",41,f4,da,88)},
	{::hx::fsObject /*  ::EReg */ ,(void *) &SVGData_obj::mStyleSplit,HX_("mStyleSplit",b6,f2,c9,d6)},
	{::hx::fsObject /*  ::EReg */ ,(void *) &SVGData_obj::mStyleValue,HX_("mStyleValue",4d,87,13,87)},
	{::hx::fsObject /*  ::EReg */ ,(void *) &SVGData_obj::mTranslateMatch,HX_("mTranslateMatch",64,40,54,84)},
	{::hx::fsObject /*  ::EReg */ ,(void *) &SVGData_obj::mScaleMatch,HX_("mScaleMatch",28,a5,bb,f9)},
	{::hx::fsObject /*  ::EReg */ ,(void *) &SVGData_obj::mMatrixMatch,HX_("mMatrixMatch",d7,7b,eb,4a)},
	{::hx::fsObject /*  ::EReg */ ,(void *) &SVGData_obj::mRotationMatch,HX_("mRotationMatch",7a,8a,ea,a2)},
	{::hx::fsObject /*  ::EReg */ ,(void *) &SVGData_obj::mURLMatch,HX_("mURLMatch",e3,c8,d9,19)},
	{::hx::fsObject /*  ::EReg */ ,(void *) &SVGData_obj::mRGBMatch,HX_("mRGBMatch",85,bc,44,a5)},
	{::hx::fsObject /*  ::format::svg::FillType */ ,(void *) &SVGData_obj::defaultFill,HX_("defaultFill",e4,c7,7a,15)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String SVGData_obj_sMemberFields[] = {
	HX_("height",e7,07,4c,02),
	HX_("width",06,b6,62,ca),
	HX_("mConvertCubics",8f,3d,64,9b),
	HX_("mGrads",38,c9,fd,c1),
	HX_("mPathParser",31,ef,22,d5),
	HX_("trimToFloat",5f,dd,dc,81),
	HX_("applyTransform",1e,6a,11,34),
	HX_("dumpGroup",6b,49,19,34),
	HX_("getColorStyle",04,19,fc,04),
	HX_("getFillStyle",38,68,1b,62),
	HX_("getFloat",26,d5,6d,62),
	HX_("getFloatStyle",2b,d6,28,ff),
	HX_("getStyleAndConvert",77,54,49,19),
	HX_("getStrokeStyle",63,39,76,24),
	HX_("getStyle",bb,b4,f4,e3),
	HX_("getStyles",58,6f,29,92),
	HX_("loadDefs",54,24,06,b3),
	HX_("loadGradient",36,26,a8,e3),
	HX_("loadGroup",39,ff,2b,b5),
	HX_("loadPath",eb,b6,f1,ba),
	HX_("loadText",f3,9d,99,bd),
	::String(null()) };

static void SVGData_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(SVGData_obj::SIN45,"SIN45");
	HX_MARK_MEMBER_NAME(SVGData_obj::TAN22,"TAN22");
	HX_MARK_MEMBER_NAME(SVGData_obj::mStyleSplit,"mStyleSplit");
	HX_MARK_MEMBER_NAME(SVGData_obj::mStyleValue,"mStyleValue");
	HX_MARK_MEMBER_NAME(SVGData_obj::mTranslateMatch,"mTranslateMatch");
	HX_MARK_MEMBER_NAME(SVGData_obj::mScaleMatch,"mScaleMatch");
	HX_MARK_MEMBER_NAME(SVGData_obj::mMatrixMatch,"mMatrixMatch");
	HX_MARK_MEMBER_NAME(SVGData_obj::mRotationMatch,"mRotationMatch");
	HX_MARK_MEMBER_NAME(SVGData_obj::mURLMatch,"mURLMatch");
	HX_MARK_MEMBER_NAME(SVGData_obj::mRGBMatch,"mRGBMatch");
	HX_MARK_MEMBER_NAME(SVGData_obj::defaultFill,"defaultFill");
};

#ifdef HXCPP_VISIT_ALLOCS
static void SVGData_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(SVGData_obj::SIN45,"SIN45");
	HX_VISIT_MEMBER_NAME(SVGData_obj::TAN22,"TAN22");
	HX_VISIT_MEMBER_NAME(SVGData_obj::mStyleSplit,"mStyleSplit");
	HX_VISIT_MEMBER_NAME(SVGData_obj::mStyleValue,"mStyleValue");
	HX_VISIT_MEMBER_NAME(SVGData_obj::mTranslateMatch,"mTranslateMatch");
	HX_VISIT_MEMBER_NAME(SVGData_obj::mScaleMatch,"mScaleMatch");
	HX_VISIT_MEMBER_NAME(SVGData_obj::mMatrixMatch,"mMatrixMatch");
	HX_VISIT_MEMBER_NAME(SVGData_obj::mRotationMatch,"mRotationMatch");
	HX_VISIT_MEMBER_NAME(SVGData_obj::mURLMatch,"mURLMatch");
	HX_VISIT_MEMBER_NAME(SVGData_obj::mRGBMatch,"mRGBMatch");
	HX_VISIT_MEMBER_NAME(SVGData_obj::defaultFill,"defaultFill");
};

#endif

::hx::Class SVGData_obj::__mClass;

static ::String SVGData_obj_sStaticFields[] = {
	HX_("SIN45",79,16,be,fa),
	HX_("TAN22",41,f4,da,88),
	HX_("mStyleSplit",b6,f2,c9,d6),
	HX_("mStyleValue",4d,87,13,87),
	HX_("mTranslateMatch",64,40,54,84),
	HX_("mScaleMatch",28,a5,bb,f9),
	HX_("mMatrixMatch",d7,7b,eb,4a),
	HX_("mRotationMatch",7a,8a,ea,a2),
	HX_("mURLMatch",e3,c8,d9,19),
	HX_("mRGBMatch",85,bc,44,a5),
	HX_("defaultFill",e4,c7,7a,15),
	HX_("parseHex",68,4c,71,d6),
	HX_("parseRGBMatch",4b,82,f8,3f),
	::String(null())
};

void SVGData_obj::__register()
{
	SVGData_obj _hx_dummy;
	SVGData_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("format.svg.SVGData",cd,22,af,06);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &SVGData_obj::__GetStatic;
	__mClass->mSetStaticField = &SVGData_obj::__SetStatic;
	__mClass->mMarkFunc = SVGData_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(SVGData_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(SVGData_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< SVGData_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = SVGData_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = SVGData_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = SVGData_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void SVGData_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_29_boot)
HXDLIN(  29)		SIN45 = ((Float)0.70710678118654752440084436210485);
            	}
{
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_30_boot)
HXDLIN(  30)		TAN22 = ((Float)0.4142135623730950488016887242097);
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_31_boot)
HXDLIN(  31)		mStyleSplit =  ::EReg_obj::__alloc( HX_CTX ,HX_(";",3b,00,00,00),HX_("g",67,00,00,00));
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_32_boot)
HXDLIN(  32)		mStyleValue =  ::EReg_obj::__alloc( HX_CTX ,HX_("\\s*(.*)\\s*:\\s*(.*)\\s*",9a,90,98,53),HX_("",00,00,00,00));
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_33_boot)
HXDLIN(  33)		mTranslateMatch =  ::EReg_obj::__alloc( HX_CTX ,HX_("translate\\((.*)[, ](.*)\\)",5f,df,a2,d4),HX_("",00,00,00,00));
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_34_boot)
HXDLIN(  34)		mScaleMatch =  ::EReg_obj::__alloc( HX_CTX ,HX_("scale\\((.*)\\)",a8,7a,82,93),HX_("",00,00,00,00));
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_35_boot)
HXDLIN(  35)		mMatrixMatch =  ::EReg_obj::__alloc( HX_CTX ,HX_("matrix\\((.*?)[, ]+(.*?)[, ]+(.*?)[, ]+(.*?)[, ]+(.*?)[, ]+(.*?)\\)",23,87,dc,ce),HX_("",00,00,00,00));
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_36_boot)
HXDLIN(  36)		mRotationMatch =  ::EReg_obj::__alloc( HX_CTX ,HX_("rotate\\(([0-9\\.]+)(\\s+([0-9\\.]+)\\s*[, ]\\s*([0-9\\.]+))?\\)",28,f3,9e,9f),HX_("",00,00,00,00));
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_37_boot)
HXDLIN(  37)		mURLMatch =  ::EReg_obj::__alloc( HX_CTX ,HX_("url\\(#(.*)\\)",1a,bd,9d,93),HX_("",00,00,00,00));
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_38_boot)
HXDLIN(  38)		mRGBMatch =  ::EReg_obj::__alloc( HX_CTX ,HX_("rgb\\s*\\(\\s*(\\d+)\\s*(%)?\\s*,\\s*(\\d+)\\s*(%)?\\s*,\\s*(\\d+)\\s*(%)?\\s*\\)",67,61,4f,4f),HX_("",00,00,00,00));
            	}
{
            	HX_STACKFRAME(&_hx_pos_a2b4c26a6f4db273_39_boot)
HXDLIN(  39)		defaultFill = ::format::svg::FillType_obj::FillSolid(0);
            	}
}

} // end namespace format
} // end namespace svg
