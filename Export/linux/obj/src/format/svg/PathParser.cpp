// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_format_svg_ArcSegment
#include <format/svg/ArcSegment.h>
#endif
#ifndef INCLUDED_format_svg_CubicSegment
#include <format/svg/CubicSegment.h>
#endif
#ifndef INCLUDED_format_svg_DrawSegment
#include <format/svg/DrawSegment.h>
#endif
#ifndef INCLUDED_format_svg_MoveSegment
#include <format/svg/MoveSegment.h>
#endif
#ifndef INCLUDED_format_svg_PathParser
#include <format/svg/PathParser.h>
#endif
#ifndef INCLUDED_format_svg_PathSegment
#include <format/svg/PathSegment.h>
#endif
#ifndef INCLUDED_format_svg_QuadraticSegment
#include <format/svg/QuadraticSegment.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_f56d127c6cf88046_49_new,"format.svg.PathParser","new",0xd4ffa517,"format.svg.PathParser.new","format/svg/PathParser.hx",49,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_57_parse,"format.svg.PathParser","parse",0xf42940aa,"format.svg.PathParser.parse","format/svg/PathParser.hx",57,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_196_commandArgs,"format.svg.PathParser","commandArgs",0x8b070fff,"format.svg.PathParser.commandArgs","format/svg/PathParser.hx",196,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_221_prevX,"format.svg.PathParser","prevX",0xff5c067c,"format.svg.PathParser.prevX","format/svg/PathParser.hx",221,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_222_prevY,"format.svg.PathParser","prevY",0xff5c067d,"format.svg.PathParser.prevY","format/svg/PathParser.hx",222,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_223_prevCX,"format.svg.PathParser","prevCX",0x71299411,"format.svg.PathParser.prevCX","format/svg/PathParser.hx",223,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_224_prevCY,"format.svg.PathParser","prevCY",0x71299412,"format.svg.PathParser.prevCY","format/svg/PathParser.hx",224,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_227_createCommand,"format.svg.PathParser","createCommand",0x31ebc926,"format.svg.PathParser.createCommand","format/svg/PathParser.hx",227,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_18_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",18,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_19_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",19,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_20_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",20,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_21_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",21,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_22_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",22,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_23_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",23,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_24_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",24,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_25_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",25,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_26_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",26,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_27_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",27,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_28_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",28,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_29_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",29,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_30_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",30,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_31_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",31,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_32_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",32,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_33_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",33,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_34_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",34,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_35_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",35,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_36_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",36,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_37_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",37,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_39_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",39,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_40_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",40,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_41_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",41,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_42_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",42,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_43_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",43,0x53270c77)
HX_LOCAL_STACK_FRAME(_hx_pos_f56d127c6cf88046_44_boot,"format.svg.PathParser","boot",0x82c9cf9b,"format.svg.PathParser.boot","format/svg/PathParser.hx",44,0x53270c77)
namespace format{
namespace svg{

void PathParser_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_49_new)
HXDLIN(  49)		if (::hx::IsNull( ::format::svg::PathParser_obj::sCommandArgs )) {
HXLINE(  51)			::format::svg::PathParser_obj::sCommandArgs = ::Array_obj< int >::__new(0);
HXLINE(  52)			{
HXLINE(  52)				int _g = 0;
HXDLIN(  52)				while((_g < 128)){
HXLINE(  52)					_g = (_g + 1);
HXDLIN(  52)					int i = (_g - 1);
HXLINE(  53)					::format::svg::PathParser_obj::sCommandArgs[i] = this->commandArgs(i);
            				}
            			}
            		}
            	}

Dynamic PathParser_obj::__CreateEmpty() { return new PathParser_obj; }

void *PathParser_obj::_hx_vtable = 0;

Dynamic PathParser_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PathParser_obj > _hx_result = new PathParser_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool PathParser_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x4dc00511;
}

::Array< ::Dynamic> PathParser_obj::parse(::String pathToParse,bool inConvertCubics){
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_57_parse)
HXLINE(  58)		this->lastMoveX = (this->lastMoveY = ( (Float)(0) ));
HXLINE(  59)		int pos = 0;
HXLINE(  60)		::Array< Float > args = ::Array_obj< Float >::__new();
HXLINE(  61)		::Array< ::Dynamic> segments = ::Array_obj< ::Dynamic>::__new();
HXLINE(  62)		int current_command_pos = 0;
HXLINE(  63)		int current_command = -1;
HXLINE(  64)		int current_args = -1;
HXLINE(  66)		this->prev = null();
HXLINE(  68)		int len = pathToParse.length;
HXLINE(  69)		bool finished = false;
HXLINE(  70)		while((pos <= len)){
HXLINE(  72)			 ::Dynamic code;
HXDLIN(  72)			if ((pos == len)) {
HXLINE(  72)				code = 32;
            			}
            			else {
HXLINE(  72)				code = pathToParse.charCodeAt(pos);
            			}
HXLINE(  73)			int command;
HXDLIN(  73)			bool command1;
HXDLIN(  73)			if (::hx::IsGreater( code,0 )) {
HXLINE(  73)				command1 = ::hx::IsLess( code,128 );
            			}
            			else {
HXLINE(  73)				command1 = false;
            			}
HXDLIN(  73)			if (command1) {
HXLINE(  73)				command = ::format::svg::PathParser_obj::sCommandArgs->__get(( (int)(code) ));
            			}
            			else {
HXLINE(  73)				command = -1;
            			}
HXLINE(  75)			if ((command == -1)) {
HXLINE(  76)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(((HX_("failed parsing path near '",37,26,1f,21) + pathToParse.substr(pos,null())) + HX_("'",27,00,00,00))));
            			}
HXLINE(  78)			if ((command == -2)) {
HXLINE(  80)				pos = (pos + 1);
            			}
            			else {
HXLINE(  82)				if ((command <= -3)) {
HXLINE(  84)					int end = (pos + 1);
HXLINE(  85)					int e_pos = -1;
HXLINE(  86)					bool seen_dot = (command == -5);
HXLINE(  87)					if ((command == -6)) {
HXLINE(  89)						e_pos = 0;
HXLINE(  90)						seen_dot = true;
            					}
HXLINE(  92)					while((end < pathToParse.length)){
HXLINE(  94)						 ::Dynamic ch = pathToParse.charCodeAt(end);
HXLINE(  95)						int code;
HXDLIN(  95)						bool code1;
HXDLIN(  95)						if (::hx::IsGreaterEq( ch,0 )) {
HXLINE(  95)							code1 = ::hx::IsGreater( ch,127 );
            						}
            						else {
HXLINE(  95)							code1 = true;
            						}
HXDLIN(  95)						if (code1) {
HXLINE(  95)							code = -1;
            						}
            						else {
HXLINE(  95)							code = ::format::svg::PathParser_obj::sCommandArgs->__get(( (int)(ch) ));
            						}
HXLINE(  96)						if ((code > -3)) {
HXLINE(  97)							goto _hx_goto_3;
            						}
HXLINE(  98)						bool _hx_tmp;
HXDLIN(  98)						if ((code == -5)) {
HXLINE(  98)							_hx_tmp = seen_dot;
            						}
            						else {
HXLINE(  98)							_hx_tmp = false;
            						}
HXDLIN(  98)						if (_hx_tmp) {
HXLINE(  99)							goto _hx_goto_3;
            						}
HXLINE( 100)						if ((e_pos >= 0)) {
HXLINE( 102)							if ((code == -4)) {
HXLINE( 104)								if ((e_pos != 0)) {
HXLINE( 105)									goto _hx_goto_3;
            								}
            							}
            							else {
HXLINE( 107)								if ((code != -3)) {
HXLINE( 108)									goto _hx_goto_3;
            								}
            							}
HXLINE( 109)							e_pos = (e_pos + 1);
            						}
            						else {
HXLINE( 111)							if ((code == -6)) {
HXLINE( 113)								if ((e_pos >= 0)) {
HXLINE( 114)									goto _hx_goto_3;
            								}
HXLINE( 115)								e_pos = 0;
HXLINE( 116)								seen_dot = true;
            							}
            							else {
HXLINE( 118)								if ((code == -4)) {
HXLINE( 119)									goto _hx_goto_3;
            								}
            							}
            						}
HXLINE( 120)						end = (end + 1);
            					}
            					_hx_goto_3:;
HXLINE( 122)					if ((current_command >= 0)) {
HXLINE( 129)						Float f = ::Std_obj::parseFloat(pathToParse.substr(pos,(end - pos)));
HXLINE( 130)						args->push(f);
            					}
HXLINE( 132)					pos = end;
            				}
            				else {
HXLINE( 136)					current_command = ( (int)(code) );
HXLINE( 137)					current_args = command;
HXLINE( 138)					finished = false;
HXLINE( 139)					current_command_pos = pos;
HXLINE( 140)					args = ::Array_obj< Float >::__new(0);
HXLINE( 141)					pos = (pos + 1);
            				}
            			}
HXLINE( 144)			Float px = ((Float)0.0);
HXLINE( 145)			Float py = ((Float)0.0);
HXLINE( 146)			if ((current_command >= 0)) {
HXLINE( 148)				if ((current_args == args->length)) {
HXLINE( 150)					bool _hx_tmp;
HXDLIN( 150)					if (inConvertCubics) {
HXLINE( 150)						_hx_tmp = ::hx::IsNotNull( this->prev );
            					}
            					else {
HXLINE( 150)						_hx_tmp = false;
            					}
HXDLIN( 150)					if (_hx_tmp) {
HXLINE( 152)						px = this->prev->prevX();
HXLINE( 153)						py = this->prev->prevY();
            					}
HXLINE( 155)					this->prev = this->createCommand(current_command,args);
HXLINE( 156)					if (::hx::IsNull( this->prev )) {
HXLINE( 157)						::String _hx_tmp = ((HX_("Unknown command ",eb,c7,2a,a4) + ::String::fromCharCode(current_command)) + HX_(" near '",0f,6f,dd,95));
HXDLIN( 157)						HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(((_hx_tmp + pathToParse.substr(current_command_pos,null())) + HX_("'",27,00,00,00))));
            					}
HXLINE( 159)					bool _hx_tmp1;
HXDLIN( 159)					if (inConvertCubics) {
HXLINE( 159)						_hx_tmp1 = (this->prev->getType() == 4);
            					}
            					else {
HXLINE( 159)						_hx_tmp1 = false;
            					}
HXDLIN( 159)					if (_hx_tmp1) {
HXLINE( 161)						 ::format::svg::CubicSegment cubic = ( ( ::format::svg::CubicSegment)(this->prev) );
HXLINE( 162)						::Array< ::Dynamic> quads = cubic->toQuadratics(px,py);
HXLINE( 163)						{
HXLINE( 163)							int _g = 0;
HXDLIN( 163)							while((_g < quads->length)){
HXLINE( 163)								 ::format::svg::QuadraticSegment q = quads->__get(_g).StaticCast<  ::format::svg::QuadraticSegment >();
HXDLIN( 163)								_g = (_g + 1);
HXLINE( 164)								segments->push(q);
            							}
            						}
            					}
            					else {
HXLINE( 167)						segments->push(this->prev);
            					}
HXLINE( 169)					finished = true;
HXLINE( 170)					if ((current_args == 0)) {
HXLINE( 172)						current_args = -1;
HXLINE( 173)						current_command = -1;
            					}
            					else {
HXLINE( 175)						if ((current_command == 77)) {
HXLINE( 176)							current_command = 76;
            						}
            						else {
HXLINE( 177)							if ((current_command == 109)) {
HXLINE( 178)								current_command = 108;
            							}
            						}
            					}
HXLINE( 180)					current_command_pos = pos;
HXLINE( 181)					args = ::Array_obj< Float >::__new(0);
            				}
            			}
            		}
HXLINE( 186)		bool _hx_tmp;
HXDLIN( 186)		if ((current_command >= 0)) {
HXLINE( 186)			_hx_tmp = !(finished);
            		}
            		else {
HXLINE( 186)			_hx_tmp = false;
            		}
HXDLIN( 186)		if (_hx_tmp) {
HXLINE( 188)			::String _hx_tmp = ((((HX_("Unfinished command (",9e,24,2d,ce) + args->length) + HX_("/",2f,00,00,00)) + current_args) + HX_(") near '",06,b6,f1,be));
HXDLIN( 188)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(((_hx_tmp + pathToParse.substr(current_command_pos,null())) + HX_("'",27,00,00,00))));
            		}
HXLINE( 192)		return segments;
            	}


HX_DEFINE_DYNAMIC_FUNC2(PathParser_obj,parse,return )

int PathParser_obj::commandArgs(int inCode){
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_196_commandArgs)
HXLINE( 197)		if ((inCode == 10)) {
HXLINE( 197)			return -2;
            		}
HXLINE( 199)		::String str = ::String::fromCharCode(inCode).toUpperCase();
HXLINE( 200)		bool _hx_tmp;
HXDLIN( 200)		if ((str >= HX_("0",30,00,00,00))) {
HXLINE( 200)			_hx_tmp = (str <= HX_("9",39,00,00,00));
            		}
            		else {
HXLINE( 200)			_hx_tmp = false;
            		}
HXDLIN( 200)		if (_hx_tmp) {
HXLINE( 201)			return -3;
            		}
HXLINE( 203)		::String _hx_switch_0 = str;
            		if (  (_hx_switch_0==HX_("+",2b,00,00,00)) ){
HXLINE( 213)			return -4;
HXDLIN( 213)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("\t",09,00,00,00)) ||  (_hx_switch_0==HX_("\n",0a,00,00,00)) ||  (_hx_switch_0==HX_("\r",0d,00,00,00)) ||  (_hx_switch_0==HX_(" ",20,00,00,00)) ||  (_hx_switch_0==HX_(",",2c,00,00,00)) ){
HXLINE( 211)			return -2;
HXDLIN( 211)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("-",2d,00,00,00)) ){
HXLINE( 212)			return -4;
HXDLIN( 212)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_(".",2e,00,00,00)) ){
HXLINE( 215)			return -5;
HXDLIN( 215)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("A",41,00,00,00)) ){
HXLINE( 210)			return 7;
HXDLIN( 210)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("C",43,00,00,00)) ){
HXLINE( 209)			return 6;
HXDLIN( 209)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("E",45,00,00,00)) ||  (_hx_switch_0==HX_("e",65,00,00,00)) ){
HXLINE( 214)			return -6;
HXDLIN( 214)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("Q",51,00,00,00)) ||  (_hx_switch_0==HX_("S",53,00,00,00)) ){
HXLINE( 208)			return 4;
HXDLIN( 208)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("L",4c,00,00,00)) ||  (_hx_switch_0==HX_("M",4d,00,00,00)) ||  (_hx_switch_0==HX_("T",54,00,00,00)) ){
HXLINE( 207)			return 2;
HXDLIN( 207)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("H",48,00,00,00)) ||  (_hx_switch_0==HX_("V",56,00,00,00)) ){
HXLINE( 206)			return 1;
HXDLIN( 206)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("Z",5a,00,00,00)) ){
HXLINE( 205)			return 0;
HXDLIN( 205)			goto _hx_goto_6;
            		}
            		_hx_goto_6:;
HXLINE( 218)		return -1;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PathParser_obj,commandArgs,return )

Float PathParser_obj::prevX(){
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_221_prevX)
HXDLIN( 221)		if (::hx::IsNotNull( this->prev )) {
HXDLIN( 221)			return this->prev->prevX();
            		}
            		else {
HXDLIN( 221)			return ( (Float)(0) );
            		}
HXDLIN( 221)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC0(PathParser_obj,prevX,return )

Float PathParser_obj::prevY(){
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_222_prevY)
HXDLIN( 222)		if (::hx::IsNotNull( this->prev )) {
HXDLIN( 222)			return this->prev->prevY();
            		}
            		else {
HXDLIN( 222)			return ( (Float)(0) );
            		}
HXDLIN( 222)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC0(PathParser_obj,prevY,return )

Float PathParser_obj::prevCX(){
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_223_prevCX)
HXDLIN( 223)		if (::hx::IsNotNull( this->prev )) {
HXDLIN( 223)			return this->prev->prevCX();
            		}
            		else {
HXDLIN( 223)			return ( (Float)(0) );
            		}
HXDLIN( 223)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC0(PathParser_obj,prevCX,return )

Float PathParser_obj::prevCY(){
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_224_prevCY)
HXDLIN( 224)		if (::hx::IsNotNull( this->prev )) {
HXDLIN( 224)			return this->prev->prevCY();
            		}
            		else {
HXDLIN( 224)			return ( (Float)(0) );
            		}
HXDLIN( 224)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC0(PathParser_obj,prevCY,return )

 ::format::svg::PathSegment PathParser_obj::createCommand(int code,::Array< Float > a){
            	HX_GC_STACKFRAME(&_hx_pos_f56d127c6cf88046_227_createCommand)
HXLINE( 228)		switch((int)(code)){
            			case (int)65: {
HXLINE( 272)				Float _hx_tmp = this->prevX();
HXDLIN( 272)				Float _hx_tmp1 = this->prevY();
HXDLIN( 272)				return  ::format::svg::ArcSegment_obj::__alloc( HX_CTX ,_hx_tmp,_hx_tmp1,a->__get(0),a->__get(1),a->__get(2),(a->__get(3) != ((Float)0.)),(a->__get(4) != ((Float)0.)),a->__get(5),a->__get(6));
            			}
            			break;
            			case (int)67: {
HXLINE( 245)				return  ::format::svg::CubicSegment_obj::__alloc( HX_CTX ,a->__get(0),a->__get(1),a->__get(2),a->__get(3),a->__get(4),a->__get(5));
            			}
            			break;
            			case (int)72: {
HXLINE( 240)				Float a1 = a->__get(0);
HXDLIN( 240)				return  ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,a1,this->prevY());
            			}
            			break;
            			case (int)76: {
HXLINE( 238)				return  ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,a->__get(0),a->__get(1));
            			}
            			break;
            			case (int)77: {
HXLINE( 231)				this->lastMoveX = a->__get(0);
HXLINE( 232)				this->lastMoveY = a->__get(1);
HXLINE( 233)				return  ::format::svg::MoveSegment_obj::__alloc( HX_CTX ,this->lastMoveX,this->lastMoveY);
            			}
            			break;
            			case (int)81: {
HXLINE( 258)				return  ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,a->__get(0),a->__get(1),a->__get(2),a->__get(3));
            			}
            			break;
            			case (int)83: {
HXLINE( 251)				Float rx = this->prevX();
HXLINE( 252)				Float ry = this->prevY();
HXLINE( 253)				Float _hx_tmp = ((rx * ( (Float)(2) )) - this->prevCX());
HXDLIN( 253)				Float _hx_tmp1 = ((ry * ( (Float)(2) )) - this->prevCY());
HXDLIN( 253)				return  ::format::svg::CubicSegment_obj::__alloc( HX_CTX ,_hx_tmp,_hx_tmp1,a->__get(0),a->__get(1),a->__get(2),a->__get(3));
            			}
            			break;
            			case (int)84: {
HXLINE( 264)				Float rx = this->prevX();
HXLINE( 265)				Float ry = this->prevY();
HXLINE( 266)				Float _hx_tmp = ((rx * ( (Float)(2) )) - this->prevCX());
HXDLIN( 266)				Float _hx_tmp1 = ((rx * ( (Float)(2) )) - this->prevCY());
HXDLIN( 266)				return  ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,_hx_tmp,_hx_tmp1,a->__get(2),a->__get(3));
            			}
            			break;
            			case (int)86: {
HXLINE( 242)				Float _hx_tmp = this->prevX();
HXDLIN( 242)				return  ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,_hx_tmp,a->__get(0));
            			}
            			break;
            			case (int)90: {
HXLINE( 278)				return  ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,this->lastMoveX,this->lastMoveY);
            			}
            			break;
            			case (int)97: {
HXLINE( 274)				Float rx = this->prevX();
HXLINE( 275)				Float ry = this->prevY();
HXLINE( 276)				return  ::format::svg::ArcSegment_obj::__alloc( HX_CTX ,rx,ry,a->__get(0),a->__get(1),a->__get(2),(a->__get(3) != ((Float)0.)),(a->__get(4) != ((Float)0.)),(a->__get(5) + rx),(a->__get(6) + ry));
            			}
            			break;
            			case (int)99: {
HXLINE( 247)				Float rx = this->prevX();
HXLINE( 248)				Float ry = this->prevY();
HXLINE( 249)				return  ::format::svg::CubicSegment_obj::__alloc( HX_CTX ,(a->__get(0) + rx),(a->__get(1) + ry),(a->__get(2) + rx),(a->__get(3) + ry),(a->__get(4) + rx),(a->__get(5) + ry));
            			}
            			break;
            			case (int)104: {
HXLINE( 241)				Float a1 = a->__get(0);
HXDLIN( 241)				Float _hx_tmp = (a1 + this->prevX());
HXDLIN( 241)				return  ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,_hx_tmp,this->prevY());
            			}
            			break;
            			case (int)108: {
HXLINE( 239)				Float a1 = a->__get(0);
HXDLIN( 239)				Float _hx_tmp = (a1 + this->prevX());
HXDLIN( 239)				Float a2 = a->__get(1);
HXDLIN( 239)				return  ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,_hx_tmp,(a2 + this->prevY()));
            			}
            			break;
            			case (int)109: {
HXLINE( 235)				Float a1 = a->__get(0);
HXDLIN( 235)				this->lastMoveX = (a1 + this->prevX());
HXLINE( 236)				Float a2 = a->__get(1);
HXDLIN( 236)				this->lastMoveY = (a2 + this->prevY());
HXLINE( 237)				return  ::format::svg::MoveSegment_obj::__alloc( HX_CTX ,this->lastMoveX,this->lastMoveY);
            			}
            			break;
            			case (int)113: {
HXLINE( 260)				Float rx = this->prevX();
HXLINE( 261)				Float ry = this->prevY();
HXLINE( 262)				return  ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,(a->__get(0) + rx),(a->__get(1) + ry),(a->__get(2) + rx),(a->__get(3) + ry));
            			}
            			break;
            			case (int)115: {
HXLINE( 255)				Float rx = this->prevX();
HXLINE( 256)				Float ry = this->prevY();
HXLINE( 257)				Float _hx_tmp = ((rx * ( (Float)(2) )) - this->prevCX());
HXDLIN( 257)				Float _hx_tmp1 = ((ry * ( (Float)(2) )) - this->prevCY());
HXDLIN( 257)				return  ::format::svg::CubicSegment_obj::__alloc( HX_CTX ,_hx_tmp,_hx_tmp1,(a->__get(0) + rx),(a->__get(1) + ry),(a->__get(2) + rx),(a->__get(3) + ry));
            			}
            			break;
            			case (int)116: {
HXLINE( 268)				Float rx = this->prevX();
HXLINE( 269)				Float ry = this->prevY();
HXLINE( 270)				Float _hx_tmp = ((rx * ( (Float)(2) )) - this->prevCX());
HXDLIN( 270)				Float _hx_tmp1 = ((ry * ( (Float)(2) )) - this->prevCY());
HXDLIN( 270)				return  ::format::svg::QuadraticSegment_obj::__alloc( HX_CTX ,_hx_tmp,_hx_tmp1,(a->__get(0) + rx),(a->__get(1) + ry));
            			}
            			break;
            			case (int)118: {
HXLINE( 243)				Float _hx_tmp = this->prevX();
HXDLIN( 243)				Float a1 = a->__get(0);
HXDLIN( 243)				return  ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,_hx_tmp,(a1 + this->prevY()));
            			}
            			break;
            			case (int)122: {
HXLINE( 281)				return  ::format::svg::DrawSegment_obj::__alloc( HX_CTX ,this->lastMoveX,this->lastMoveY);
            			}
            			break;
            		}
HXLINE( 284)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(PathParser_obj,createCommand,return )

::Array< int > PathParser_obj::sCommandArgs;

int PathParser_obj::MOVE;

int PathParser_obj::MOVER;

int PathParser_obj::LINE;

int PathParser_obj::LINER;

int PathParser_obj::HLINE;

int PathParser_obj::HLINER;

int PathParser_obj::VLINE;

int PathParser_obj::VLINER;

int PathParser_obj::CUBIC;

int PathParser_obj::CUBICR;

int PathParser_obj::SCUBIC;

int PathParser_obj::SCUBICR;

int PathParser_obj::QUAD;

int PathParser_obj::QUADR;

int PathParser_obj::SQUAD;

int PathParser_obj::SQUADR;

int PathParser_obj::ARC;

int PathParser_obj::ARCR;

int PathParser_obj::CLOSE;

int PathParser_obj::CLOSER;

int PathParser_obj::UNKNOWN;

int PathParser_obj::SEPARATOR;

int PathParser_obj::FLOAT;

int PathParser_obj::FLOAT_SIGN;

int PathParser_obj::FLOAT_DOT;

int PathParser_obj::FLOAT_EXP;


::hx::ObjectPtr< PathParser_obj > PathParser_obj::__new() {
	::hx::ObjectPtr< PathParser_obj > __this = new PathParser_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< PathParser_obj > PathParser_obj::__alloc(::hx::Ctx *_hx_ctx) {
	PathParser_obj *__this = (PathParser_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(PathParser_obj), true, "format.svg.PathParser"));
	*(void **)__this = PathParser_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

PathParser_obj::PathParser_obj()
{
}

void PathParser_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(PathParser);
	HX_MARK_MEMBER_NAME(lastMoveX,"lastMoveX");
	HX_MARK_MEMBER_NAME(lastMoveY,"lastMoveY");
	HX_MARK_MEMBER_NAME(prev,"prev");
	HX_MARK_END_CLASS();
}

void PathParser_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(lastMoveX,"lastMoveX");
	HX_VISIT_MEMBER_NAME(lastMoveY,"lastMoveY");
	HX_VISIT_MEMBER_NAME(prev,"prev");
}

::hx::Val PathParser_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"prev") ) { return ::hx::Val( prev ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"parse") ) { return ::hx::Val( parse_dyn() ); }
		if (HX_FIELD_EQ(inName,"prevX") ) { return ::hx::Val( prevX_dyn() ); }
		if (HX_FIELD_EQ(inName,"prevY") ) { return ::hx::Val( prevY_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"prevCX") ) { return ::hx::Val( prevCX_dyn() ); }
		if (HX_FIELD_EQ(inName,"prevCY") ) { return ::hx::Val( prevCY_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"lastMoveX") ) { return ::hx::Val( lastMoveX ); }
		if (HX_FIELD_EQ(inName,"lastMoveY") ) { return ::hx::Val( lastMoveY ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"commandArgs") ) { return ::hx::Val( commandArgs_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"createCommand") ) { return ::hx::Val( createCommand_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool PathParser_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"sCommandArgs") ) { outValue = ( sCommandArgs ); return true; }
	}
	return false;
}

::hx::Val PathParser_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"prev") ) { prev=inValue.Cast<  ::format::svg::PathSegment >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"lastMoveX") ) { lastMoveX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastMoveY") ) { lastMoveY=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool PathParser_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"sCommandArgs") ) { sCommandArgs=ioValue.Cast< ::Array< int > >(); return true; }
	}
	return false;
}

void PathParser_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("lastMoveX",f1,f9,12,59));
	outFields->push(HX_("lastMoveY",f2,f9,12,59));
	outFields->push(HX_("prev",f3,be,5e,4a));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo PathParser_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(PathParser_obj,lastMoveX),HX_("lastMoveX",f1,f9,12,59)},
	{::hx::fsFloat,(int)offsetof(PathParser_obj,lastMoveY),HX_("lastMoveY",f2,f9,12,59)},
	{::hx::fsObject /*  ::format::svg::PathSegment */ ,(int)offsetof(PathParser_obj,prev),HX_("prev",f3,be,5e,4a)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo PathParser_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /* ::Array< int > */ ,(void *) &PathParser_obj::sCommandArgs,HX_("sCommandArgs",95,02,06,4b)},
	{::hx::fsInt,(void *) &PathParser_obj::MOVE,HX_("MOVE",11,ab,21,33)},
	{::hx::fsInt,(void *) &PathParser_obj::MOVER,HX_("MOVER",21,04,54,8a)},
	{::hx::fsInt,(void *) &PathParser_obj::LINE,HX_("LINE",f4,df,73,32)},
	{::hx::fsInt,(void *) &PathParser_obj::LINER,HX_("LINER",de,15,f0,f2)},
	{::hx::fsInt,(void *) &PathParser_obj::HLINE,HX_("HLINE",3c,a4,4d,a7)},
	{::hx::fsInt,(void *) &PathParser_obj::HLINER,HX_("HLINER",96,10,a2,bc)},
	{::hx::fsInt,(void *) &PathParser_obj::VLINE,HX_("VLINE",4a,c3,e9,b6)},
	{::hx::fsInt,(void *) &PathParser_obj::VLINER,HX_("VLINER",c8,1d,a1,55)},
	{::hx::fsInt,(void *) &PathParser_obj::CUBIC,HX_("CUBIC",2a,55,3a,cc)},
	{::hx::fsInt,(void *) &PathParser_obj::CUBICR,HX_("CUBICR",e8,2f,d0,e6)},
	{::hx::fsInt,(void *) &PathParser_obj::SCUBIC,HX_("SCUBIC",f7,47,d9,fb)},
	{::hx::fsInt,(void *) &PathParser_obj::SCUBICR,HX_("SCUBICR",7b,b0,45,62)},
	{::hx::fsInt,(void *) &PathParser_obj::QUAD,HX_("QUAD",c7,00,cb,35)},
	{::hx::fsInt,(void *) &PathParser_obj::QUADR,HX_("QUADR",ab,ad,d5,db)},
	{::hx::fsInt,(void *) &PathParser_obj::SQUAD,HX_("SQUAD",9a,26,0d,00)},
	{::hx::fsInt,(void *) &PathParser_obj::SQUADR,HX_("SQUADR",78,a0,74,0b)},
	{::hx::fsInt,(void *) &PathParser_obj::ARC,HX_("ARC",32,9a,31,00)},
	{::hx::fsInt,(void *) &PathParser_obj::ARCR,HX_("ARCR",e0,51,35,2b)},
	{::hx::fsInt,(void *) &PathParser_obj::CLOSE,HX_("CLOSE",98,4f,51,c6)},
	{::hx::fsInt,(void *) &PathParser_obj::CLOSER,HX_("CLOSER",ba,55,d4,c0)},
	{::hx::fsInt,(void *) &PathParser_obj::UNKNOWN,HX_("UNKNOWN",6a,f7,4e,61)},
	{::hx::fsInt,(void *) &PathParser_obj::SEPARATOR,HX_("SEPARATOR",45,d0,d7,2c)},
	{::hx::fsInt,(void *) &PathParser_obj::FLOAT,HX_("FLOAT",7c,fd,84,80)},
	{::hx::fsInt,(void *) &PathParser_obj::FLOAT_SIGN,HX_("FLOAT_SIGN",20,15,ac,e9)},
	{::hx::fsInt,(void *) &PathParser_obj::FLOAT_DOT,HX_("FLOAT_DOT",e6,8e,f6,17)},
	{::hx::fsInt,(void *) &PathParser_obj::FLOAT_EXP,HX_("FLOAT_EXP",fa,58,f7,17)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String PathParser_obj_sMemberFields[] = {
	HX_("lastMoveX",f1,f9,12,59),
	HX_("lastMoveY",f2,f9,12,59),
	HX_("prev",f3,be,5e,4a),
	HX_("parse",33,90,55,bd),
	HX_("commandArgs",48,2c,d5,dd),
	HX_("prevX",05,56,88,c8),
	HX_("prevY",06,56,88,c8),
	HX_("prevCX",68,dc,c2,ae),
	HX_("prevCY",69,dc,c2,ae),
	HX_("createCommand",af,49,b0,69),
	::String(null()) };

static void PathParser_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(PathParser_obj::sCommandArgs,"sCommandArgs");
	HX_MARK_MEMBER_NAME(PathParser_obj::MOVE,"MOVE");
	HX_MARK_MEMBER_NAME(PathParser_obj::MOVER,"MOVER");
	HX_MARK_MEMBER_NAME(PathParser_obj::LINE,"LINE");
	HX_MARK_MEMBER_NAME(PathParser_obj::LINER,"LINER");
	HX_MARK_MEMBER_NAME(PathParser_obj::HLINE,"HLINE");
	HX_MARK_MEMBER_NAME(PathParser_obj::HLINER,"HLINER");
	HX_MARK_MEMBER_NAME(PathParser_obj::VLINE,"VLINE");
	HX_MARK_MEMBER_NAME(PathParser_obj::VLINER,"VLINER");
	HX_MARK_MEMBER_NAME(PathParser_obj::CUBIC,"CUBIC");
	HX_MARK_MEMBER_NAME(PathParser_obj::CUBICR,"CUBICR");
	HX_MARK_MEMBER_NAME(PathParser_obj::SCUBIC,"SCUBIC");
	HX_MARK_MEMBER_NAME(PathParser_obj::SCUBICR,"SCUBICR");
	HX_MARK_MEMBER_NAME(PathParser_obj::QUAD,"QUAD");
	HX_MARK_MEMBER_NAME(PathParser_obj::QUADR,"QUADR");
	HX_MARK_MEMBER_NAME(PathParser_obj::SQUAD,"SQUAD");
	HX_MARK_MEMBER_NAME(PathParser_obj::SQUADR,"SQUADR");
	HX_MARK_MEMBER_NAME(PathParser_obj::ARC,"ARC");
	HX_MARK_MEMBER_NAME(PathParser_obj::ARCR,"ARCR");
	HX_MARK_MEMBER_NAME(PathParser_obj::CLOSE,"CLOSE");
	HX_MARK_MEMBER_NAME(PathParser_obj::CLOSER,"CLOSER");
	HX_MARK_MEMBER_NAME(PathParser_obj::UNKNOWN,"UNKNOWN");
	HX_MARK_MEMBER_NAME(PathParser_obj::SEPARATOR,"SEPARATOR");
	HX_MARK_MEMBER_NAME(PathParser_obj::FLOAT,"FLOAT");
	HX_MARK_MEMBER_NAME(PathParser_obj::FLOAT_SIGN,"FLOAT_SIGN");
	HX_MARK_MEMBER_NAME(PathParser_obj::FLOAT_DOT,"FLOAT_DOT");
	HX_MARK_MEMBER_NAME(PathParser_obj::FLOAT_EXP,"FLOAT_EXP");
};

#ifdef HXCPP_VISIT_ALLOCS
static void PathParser_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(PathParser_obj::sCommandArgs,"sCommandArgs");
	HX_VISIT_MEMBER_NAME(PathParser_obj::MOVE,"MOVE");
	HX_VISIT_MEMBER_NAME(PathParser_obj::MOVER,"MOVER");
	HX_VISIT_MEMBER_NAME(PathParser_obj::LINE,"LINE");
	HX_VISIT_MEMBER_NAME(PathParser_obj::LINER,"LINER");
	HX_VISIT_MEMBER_NAME(PathParser_obj::HLINE,"HLINE");
	HX_VISIT_MEMBER_NAME(PathParser_obj::HLINER,"HLINER");
	HX_VISIT_MEMBER_NAME(PathParser_obj::VLINE,"VLINE");
	HX_VISIT_MEMBER_NAME(PathParser_obj::VLINER,"VLINER");
	HX_VISIT_MEMBER_NAME(PathParser_obj::CUBIC,"CUBIC");
	HX_VISIT_MEMBER_NAME(PathParser_obj::CUBICR,"CUBICR");
	HX_VISIT_MEMBER_NAME(PathParser_obj::SCUBIC,"SCUBIC");
	HX_VISIT_MEMBER_NAME(PathParser_obj::SCUBICR,"SCUBICR");
	HX_VISIT_MEMBER_NAME(PathParser_obj::QUAD,"QUAD");
	HX_VISIT_MEMBER_NAME(PathParser_obj::QUADR,"QUADR");
	HX_VISIT_MEMBER_NAME(PathParser_obj::SQUAD,"SQUAD");
	HX_VISIT_MEMBER_NAME(PathParser_obj::SQUADR,"SQUADR");
	HX_VISIT_MEMBER_NAME(PathParser_obj::ARC,"ARC");
	HX_VISIT_MEMBER_NAME(PathParser_obj::ARCR,"ARCR");
	HX_VISIT_MEMBER_NAME(PathParser_obj::CLOSE,"CLOSE");
	HX_VISIT_MEMBER_NAME(PathParser_obj::CLOSER,"CLOSER");
	HX_VISIT_MEMBER_NAME(PathParser_obj::UNKNOWN,"UNKNOWN");
	HX_VISIT_MEMBER_NAME(PathParser_obj::SEPARATOR,"SEPARATOR");
	HX_VISIT_MEMBER_NAME(PathParser_obj::FLOAT,"FLOAT");
	HX_VISIT_MEMBER_NAME(PathParser_obj::FLOAT_SIGN,"FLOAT_SIGN");
	HX_VISIT_MEMBER_NAME(PathParser_obj::FLOAT_DOT,"FLOAT_DOT");
	HX_VISIT_MEMBER_NAME(PathParser_obj::FLOAT_EXP,"FLOAT_EXP");
};

#endif

::hx::Class PathParser_obj::__mClass;

static ::String PathParser_obj_sStaticFields[] = {
	HX_("sCommandArgs",95,02,06,4b),
	HX_("MOVE",11,ab,21,33),
	HX_("MOVER",21,04,54,8a),
	HX_("LINE",f4,df,73,32),
	HX_("LINER",de,15,f0,f2),
	HX_("HLINE",3c,a4,4d,a7),
	HX_("HLINER",96,10,a2,bc),
	HX_("VLINE",4a,c3,e9,b6),
	HX_("VLINER",c8,1d,a1,55),
	HX_("CUBIC",2a,55,3a,cc),
	HX_("CUBICR",e8,2f,d0,e6),
	HX_("SCUBIC",f7,47,d9,fb),
	HX_("SCUBICR",7b,b0,45,62),
	HX_("QUAD",c7,00,cb,35),
	HX_("QUADR",ab,ad,d5,db),
	HX_("SQUAD",9a,26,0d,00),
	HX_("SQUADR",78,a0,74,0b),
	HX_("ARC",32,9a,31,00),
	HX_("ARCR",e0,51,35,2b),
	HX_("CLOSE",98,4f,51,c6),
	HX_("CLOSER",ba,55,d4,c0),
	HX_("UNKNOWN",6a,f7,4e,61),
	HX_("SEPARATOR",45,d0,d7,2c),
	HX_("FLOAT",7c,fd,84,80),
	HX_("FLOAT_SIGN",20,15,ac,e9),
	HX_("FLOAT_DOT",e6,8e,f6,17),
	HX_("FLOAT_EXP",fa,58,f7,17),
	::String(null())
};

void PathParser_obj::__register()
{
	PathParser_obj _hx_dummy;
	PathParser_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("format.svg.PathParser",a5,cd,bb,16);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &PathParser_obj::__GetStatic;
	__mClass->mSetStaticField = &PathParser_obj::__SetStatic;
	__mClass->mMarkFunc = PathParser_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(PathParser_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(PathParser_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< PathParser_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = PathParser_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PathParser_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PathParser_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void PathParser_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_18_boot)
HXDLIN(  18)		MOVE = 77;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_19_boot)
HXDLIN(  19)		MOVER = 109;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_20_boot)
HXDLIN(  20)		LINE = 76;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_21_boot)
HXDLIN(  21)		LINER = 108;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_22_boot)
HXDLIN(  22)		HLINE = 72;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_23_boot)
HXDLIN(  23)		HLINER = 104;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_24_boot)
HXDLIN(  24)		VLINE = 86;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_25_boot)
HXDLIN(  25)		VLINER = 118;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_26_boot)
HXDLIN(  26)		CUBIC = 67;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_27_boot)
HXDLIN(  27)		CUBICR = 99;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_28_boot)
HXDLIN(  28)		SCUBIC = 83;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_29_boot)
HXDLIN(  29)		SCUBICR = 115;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_30_boot)
HXDLIN(  30)		QUAD = 81;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_31_boot)
HXDLIN(  31)		QUADR = 113;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_32_boot)
HXDLIN(  32)		SQUAD = 84;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_33_boot)
HXDLIN(  33)		SQUADR = 116;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_34_boot)
HXDLIN(  34)		ARC = 65;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_35_boot)
HXDLIN(  35)		ARCR = 97;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_36_boot)
HXDLIN(  36)		CLOSE = 90;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_37_boot)
HXDLIN(  37)		CLOSER = 122;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_39_boot)
HXDLIN(  39)		UNKNOWN = -1;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_40_boot)
HXDLIN(  40)		SEPARATOR = -2;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_41_boot)
HXDLIN(  41)		FLOAT = -3;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_42_boot)
HXDLIN(  42)		FLOAT_SIGN = -4;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_43_boot)
HXDLIN(  43)		FLOAT_DOT = -5;
            	}
{
            	HX_STACKFRAME(&_hx_pos_f56d127c6cf88046_44_boot)
HXDLIN(  44)		FLOAT_EXP = -6;
            	}
}

} // end namespace format
} // end namespace svg
