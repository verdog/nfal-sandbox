// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_format_svg_FillType
#include <format/svg/FillType.h>
#endif
#ifndef INCLUDED_format_svg_Text
#include <format/svg/Text.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_ac4be4d6f9a94e94_8_new,"format.svg.Text","new",0x9481d320,"format.svg.Text.new","format/svg/Text.hx",8,0x00c6d00e)
namespace format{
namespace svg{

void Text_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_ac4be4d6f9a94e94_8_new)
            	}

Dynamic Text_obj::__CreateEmpty() { return new Text_obj; }

void *Text_obj::_hx_vtable = 0;

Dynamic Text_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Text_obj > _hx_result = new Text_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Text_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7fffdf02;
}


Text_obj::Text_obj()
{
}

void Text_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Text);
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(x,"x");
	HX_MARK_MEMBER_NAME(y,"y");
	HX_MARK_MEMBER_NAME(matrix,"matrix");
	HX_MARK_MEMBER_NAME(text,"text");
	HX_MARK_MEMBER_NAME(fill,"fill");
	HX_MARK_MEMBER_NAME(fill_alpha,"fill_alpha");
	HX_MARK_MEMBER_NAME(stroke_alpha,"stroke_alpha");
	HX_MARK_MEMBER_NAME(stroke_colour,"stroke_colour");
	HX_MARK_MEMBER_NAME(stroke_width,"stroke_width");
	HX_MARK_MEMBER_NAME(font_family,"font_family");
	HX_MARK_MEMBER_NAME(font_size,"font_size");
	HX_MARK_MEMBER_NAME(kerning,"kerning");
	HX_MARK_MEMBER_NAME(letter_spacing,"letter_spacing");
	HX_MARK_MEMBER_NAME(text_align,"text_align");
	HX_MARK_END_CLASS();
}

void Text_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(x,"x");
	HX_VISIT_MEMBER_NAME(y,"y");
	HX_VISIT_MEMBER_NAME(matrix,"matrix");
	HX_VISIT_MEMBER_NAME(text,"text");
	HX_VISIT_MEMBER_NAME(fill,"fill");
	HX_VISIT_MEMBER_NAME(fill_alpha,"fill_alpha");
	HX_VISIT_MEMBER_NAME(stroke_alpha,"stroke_alpha");
	HX_VISIT_MEMBER_NAME(stroke_colour,"stroke_colour");
	HX_VISIT_MEMBER_NAME(stroke_width,"stroke_width");
	HX_VISIT_MEMBER_NAME(font_family,"font_family");
	HX_VISIT_MEMBER_NAME(font_size,"font_size");
	HX_VISIT_MEMBER_NAME(kerning,"kerning");
	HX_VISIT_MEMBER_NAME(letter_spacing,"letter_spacing");
	HX_VISIT_MEMBER_NAME(text_align,"text_align");
}

::hx::Val Text_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return ::hx::Val( x ); }
		if (HX_FIELD_EQ(inName,"y") ) { return ::hx::Val( y ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { return ::hx::Val( name ); }
		if (HX_FIELD_EQ(inName,"text") ) { return ::hx::Val( text ); }
		if (HX_FIELD_EQ(inName,"fill") ) { return ::hx::Val( fill ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { return ::hx::Val( matrix ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"kerning") ) { return ::hx::Val( kerning ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"font_size") ) { return ::hx::Val( font_size ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"fill_alpha") ) { return ::hx::Val( fill_alpha ); }
		if (HX_FIELD_EQ(inName,"text_align") ) { return ::hx::Val( text_align ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"font_family") ) { return ::hx::Val( font_family ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"stroke_alpha") ) { return ::hx::Val( stroke_alpha ); }
		if (HX_FIELD_EQ(inName,"stroke_width") ) { return ::hx::Val( stroke_width ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"stroke_colour") ) { return ::hx::Val( stroke_colour ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"letter_spacing") ) { return ::hx::Val( letter_spacing ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Text_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { y=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { name=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"text") ) { text=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fill") ) { fill=inValue.Cast<  ::format::svg::FillType >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { matrix=inValue.Cast<  ::openfl::geom::Matrix >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"kerning") ) { kerning=inValue.Cast< Float >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"font_size") ) { font_size=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"fill_alpha") ) { fill_alpha=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"text_align") ) { text_align=inValue.Cast< ::String >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"font_family") ) { font_family=inValue.Cast< ::String >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"stroke_alpha") ) { stroke_alpha=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stroke_width") ) { stroke_width=inValue.Cast< Float >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"stroke_colour") ) { stroke_colour=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"letter_spacing") ) { letter_spacing=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Text_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("name",4b,72,ff,48));
	outFields->push(HX_("x",78,00,00,00));
	outFields->push(HX_("y",79,00,00,00));
	outFields->push(HX_("matrix",41,36,c8,bb));
	outFields->push(HX_("text",ad,cc,f9,4c));
	outFields->push(HX_("fill",83,ce,bb,43));
	outFields->push(HX_("fill_alpha",62,01,84,ec));
	outFields->push(HX_("stroke_alpha",57,3c,28,73));
	outFields->push(HX_("stroke_colour",33,8d,57,d4));
	outFields->push(HX_("stroke_width",ff,4a,f4,1b));
	outFields->push(HX_("font_family",54,fb,97,a0));
	outFields->push(HX_("font_size",71,f0,12,18));
	outFields->push(HX_("kerning",cc,ba,37,b0));
	outFields->push(HX_("letter_spacing",ea,8f,ec,6d));
	outFields->push(HX_("text_align",73,aa,d4,1f));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Text_obj_sMemberStorageInfo[] = {
	{::hx::fsString,(int)offsetof(Text_obj,name),HX_("name",4b,72,ff,48)},
	{::hx::fsFloat,(int)offsetof(Text_obj,x),HX_("x",78,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Text_obj,y),HX_("y",79,00,00,00)},
	{::hx::fsObject /*  ::openfl::geom::Matrix */ ,(int)offsetof(Text_obj,matrix),HX_("matrix",41,36,c8,bb)},
	{::hx::fsString,(int)offsetof(Text_obj,text),HX_("text",ad,cc,f9,4c)},
	{::hx::fsObject /*  ::format::svg::FillType */ ,(int)offsetof(Text_obj,fill),HX_("fill",83,ce,bb,43)},
	{::hx::fsFloat,(int)offsetof(Text_obj,fill_alpha),HX_("fill_alpha",62,01,84,ec)},
	{::hx::fsFloat,(int)offsetof(Text_obj,stroke_alpha),HX_("stroke_alpha",57,3c,28,73)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Text_obj,stroke_colour),HX_("stroke_colour",33,8d,57,d4)},
	{::hx::fsFloat,(int)offsetof(Text_obj,stroke_width),HX_("stroke_width",ff,4a,f4,1b)},
	{::hx::fsString,(int)offsetof(Text_obj,font_family),HX_("font_family",54,fb,97,a0)},
	{::hx::fsFloat,(int)offsetof(Text_obj,font_size),HX_("font_size",71,f0,12,18)},
	{::hx::fsFloat,(int)offsetof(Text_obj,kerning),HX_("kerning",cc,ba,37,b0)},
	{::hx::fsFloat,(int)offsetof(Text_obj,letter_spacing),HX_("letter_spacing",ea,8f,ec,6d)},
	{::hx::fsString,(int)offsetof(Text_obj,text_align),HX_("text_align",73,aa,d4,1f)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Text_obj_sStaticStorageInfo = 0;
#endif

static ::String Text_obj_sMemberFields[] = {
	HX_("name",4b,72,ff,48),
	HX_("x",78,00,00,00),
	HX_("y",79,00,00,00),
	HX_("matrix",41,36,c8,bb),
	HX_("text",ad,cc,f9,4c),
	HX_("fill",83,ce,bb,43),
	HX_("fill_alpha",62,01,84,ec),
	HX_("stroke_alpha",57,3c,28,73),
	HX_("stroke_colour",33,8d,57,d4),
	HX_("stroke_width",ff,4a,f4,1b),
	HX_("font_family",54,fb,97,a0),
	HX_("font_size",71,f0,12,18),
	HX_("kerning",cc,ba,37,b0),
	HX_("letter_spacing",ea,8f,ec,6d),
	HX_("text_align",73,aa,d4,1f),
	::String(null()) };

::hx::Class Text_obj::__mClass;

void Text_obj::__register()
{
	Text_obj _hx_dummy;
	Text_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("format.svg.Text",2e,03,9a,70);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Text_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Text_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Text_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Text_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace format
} // end namespace svg
